{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Pen programming language Pen is the parallel, concurrent, and functional programming language for scalable software development , focused on software maintainability and portability. import Core'Number import Os'File # The `\\` prefix for \u03bb denotes a function. findAnswer = \\(kind string) number { # Secret source... 21 } main = \\(ctx context) none { # The `go` function runs a given function in parallel. # `x` is a future for the computed value. x = go(\\() number { findAnswer(\"humanity\") }) y = findAnswer(\"dolphins\") _ = File'Write(ctx, File'StdOut(), Number'String(x() + y)) none } Vision Pen aims to make large-scale software development efficient where many engineers develop software together for a long time. To realize that, it focuses on software maintainability and portability . Maintainability Simplicity: The language is small and easy to learn yet full featured. Testability: Tests are always fast and reliable. Flexibility: Developers can change codes easily without regression. Portability Programs written in Pen can be ported to different platforms including WebAssembly . Features Minimal language Its syntax and type system are small, simple, and easy to learn. Yet, the language supports all the modern features. Concurrent/parallel computation The language and its runtime enables thread-safe concurrent/parallel computation. For more information, see Concurrency and parallelism . Reliable testing Tests are always deterministic and fast. Tests are side-effect free and independent from test environment. No built-in system library There is no built-in system library dependent on platforms. Developers choose system packages suitable for their applications. System packages encapsulate platform-dependent codes and side effects. No other kind of package causes side effects without explicit injection. Security No runtime exception Memory safe No undefined behavior No data race Even more... Static typing Immutable values Pure functions by default Errors as values Asynchronous I/O Cross compile Rust /C Foreign Function Interface (FFI) License Pen is dual-licensed under MIT and Apache 2.0 .","title":"Overview"},{"location":"#pen-programming-language","text":"Pen is the parallel, concurrent, and functional programming language for scalable software development , focused on software maintainability and portability. import Core'Number import Os'File # The `\\` prefix for \u03bb denotes a function. findAnswer = \\(kind string) number { # Secret source... 21 } main = \\(ctx context) none { # The `go` function runs a given function in parallel. # `x` is a future for the computed value. x = go(\\() number { findAnswer(\"humanity\") }) y = findAnswer(\"dolphins\") _ = File'Write(ctx, File'StdOut(), Number'String(x() + y)) none }","title":"Pen programming language"},{"location":"#vision","text":"Pen aims to make large-scale software development efficient where many engineers develop software together for a long time. To realize that, it focuses on software maintainability and portability . Maintainability Simplicity: The language is small and easy to learn yet full featured. Testability: Tests are always fast and reliable. Flexibility: Developers can change codes easily without regression. Portability Programs written in Pen can be ported to different platforms including WebAssembly .","title":"Vision"},{"location":"#features","text":"","title":"Features"},{"location":"#minimal-language","text":"Its syntax and type system are small, simple, and easy to learn. Yet, the language supports all the modern features.","title":"Minimal language"},{"location":"#concurrentparallel-computation","text":"The language and its runtime enables thread-safe concurrent/parallel computation. For more information, see Concurrency and parallelism .","title":"Concurrent/parallel computation"},{"location":"#reliable-testing","text":"Tests are always deterministic and fast. Tests are side-effect free and independent from test environment.","title":"Reliable testing"},{"location":"#no-built-in-system-library","text":"There is no built-in system library dependent on platforms. Developers choose system packages suitable for their applications. System packages encapsulate platform-dependent codes and side effects. No other kind of package causes side effects without explicit injection.","title":"No built-in system library"},{"location":"#security","text":"No runtime exception Memory safe No undefined behavior No data race","title":"Security"},{"location":"#even-more","text":"Static typing Immutable values Pure functions by default Errors as values Asynchronous I/O Cross compile Rust /C Foreign Function Interface (FFI)","title":"Even more..."},{"location":"#license","text":"Pen is dual-licensed under MIT and Apache 2.0 .","title":"License"},{"location":"roadmap/","text":"Roadmap Items are ordered by priority. Basic syntax CPS transformation Asynchronous I/O Asynchronous synchronization Capability-based effect system Performant GC Automatic reference counting Foreign function interface Basic OS interface WASM backend Stream-based list type Testing framework TCP/UDP sockets System time Asynchronous operations Parallel computation Binary operations List comprehension Multiple system packages Map type Code formatter Documentation generator Process management Reflection Mutable state Thread safety IDE/editor support Language server Metaprogramming Code generator Serialization / deserialization Package manager Vector type Web browser interface JavaScript backend (?)","title":"Roadmap"},{"location":"roadmap/#roadmap","text":"Items are ordered by priority. Basic syntax CPS transformation Asynchronous I/O Asynchronous synchronization Capability-based effect system Performant GC Automatic reference counting Foreign function interface Basic OS interface WASM backend Stream-based list type Testing framework TCP/UDP sockets System time Asynchronous operations Parallel computation Binary operations List comprehension Multiple system packages Map type Code formatter Documentation generator Process management Reflection Mutable state Thread safety IDE/editor support Language server Metaprogramming Code generator Serialization / deserialization Package manager Vector type Web browser interface JavaScript backend (?)","title":"Roadmap"},{"location":"the-zen/","text":"The Zen Simple is better than complex. Explicit is better than implicit. Clear is better than clever. One way to do one thing One solution for many problems Steady value over volatile value References Go Proverbs The Zen of Python Zen | The Zig programming language","title":"The Zen"},{"location":"the-zen/#the-zen","text":"Simple is better than complex. Explicit is better than implicit. Clear is better than clever. One way to do one thing One solution for many problems Steady value over volatile value","title":"The Zen"},{"location":"the-zen/#references","text":"Go Proverbs The Zen of Python Zen | The Zig programming language","title":"References"},{"location":"advanced-features/cross-compile/","text":"Cross compile The language's compiler supports cross compile . To compile applications and libraries for different targets, specify the --target option of the pen build subcommand. For example, run the following command to compile a wasm32 binary for the WASI platform. pen build --target wasm32-wasi Note that we currently support those targets via Rust 's cross compiler toolchain. Please install a Rust compiler through rustup to enable installation of toolchains for different targets. Supported targets Run pen build --help to see all supported targets. System package support Cross compile support of system packages are totally up to their developers. For example, the Os standard system package supports most targets as long as their platforms expose OS-like APIs. However, some custom system packages might not support those targets because of their limited use cases.","title":"Cross compile"},{"location":"advanced-features/cross-compile/#cross-compile","text":"The language's compiler supports cross compile . To compile applications and libraries for different targets, specify the --target option of the pen build subcommand. For example, run the following command to compile a wasm32 binary for the WASI platform. pen build --target wasm32-wasi Note that we currently support those targets via Rust 's cross compiler toolchain. Please install a Rust compiler through rustup to enable installation of toolchains for different targets.","title":"Cross compile"},{"location":"advanced-features/cross-compile/#supported-targets","text":"Run pen build --help to see all supported targets.","title":"Supported targets"},{"location":"advanced-features/cross-compile/#system-package-support","text":"Cross compile support of system packages are totally up to their developers. For example, the Os standard system package supports most targets as long as their platforms expose OS-like APIs. However, some custom system packages might not support those targets because of their limited use cases.","title":"System package support"},{"location":"advanced-features/ffi/","text":"Foreign Function Interface (FFI) Using FFI, you can import or export functions in foreign languages, such as Rust and C. Importing functions in foreign languages You can import functions in foreign languages using foreign import statements . The statements specify the foreign functions' calling convention, names and types. You might specify calling conventions of foreign functions in a format of string literals after import foreign keywords optionally. Currently, only the C calling convention is supported as \"c\" . If the options are omitted, the functions are imported with the native calling convention of Pen. import foreign \"c\" foo \\(number, number) number Caveat: You can import foreign functions that might cause side effects only in system packages . See also Writing system packages . Exporting functions to foreign languages You can export functions to foreign languages using foreign function definitions , which have foreign keywords in front of normal function definitions. You might specify calling conventions of exported foreign functions optionally after foreign keywords as well as imported foreign functions . foreign \"c\" foo = \\(x number, y number) number { ... } Building libraries of foreign languages During builds of your packages, you might want to build libraries of foreign languages so that you can use their functions. If that's your case, you can set up pen-ffi scripts in your packages. The script files run on every build and output absolute paths to .a archive files of your libraries in foreign languages built by the scripts. The script files may or may not have file extensions. The pen-ffi scripts should accept the following command line arguments. Argument Required Description -t <target> No Custom target triple of builds One of examples in practice is a pen-ffi.sh file in the Core library . Native calling convention in Pen TBD","title":"Foreign Function Interface (FFI)"},{"location":"advanced-features/ffi/#foreign-function-interface-ffi","text":"Using FFI, you can import or export functions in foreign languages, such as Rust and C.","title":"Foreign Function Interface (FFI)"},{"location":"advanced-features/ffi/#importing-functions-in-foreign-languages","text":"You can import functions in foreign languages using foreign import statements . The statements specify the foreign functions' calling convention, names and types. You might specify calling conventions of foreign functions in a format of string literals after import foreign keywords optionally. Currently, only the C calling convention is supported as \"c\" . If the options are omitted, the functions are imported with the native calling convention of Pen. import foreign \"c\" foo \\(number, number) number Caveat: You can import foreign functions that might cause side effects only in system packages . See also Writing system packages .","title":"Importing functions in foreign languages"},{"location":"advanced-features/ffi/#exporting-functions-to-foreign-languages","text":"You can export functions to foreign languages using foreign function definitions , which have foreign keywords in front of normal function definitions. You might specify calling conventions of exported foreign functions optionally after foreign keywords as well as imported foreign functions . foreign \"c\" foo = \\(x number, y number) number { ... }","title":"Exporting functions to foreign languages"},{"location":"advanced-features/ffi/#building-libraries-of-foreign-languages","text":"During builds of your packages, you might want to build libraries of foreign languages so that you can use their functions. If that's your case, you can set up pen-ffi scripts in your packages. The script files run on every build and output absolute paths to .a archive files of your libraries in foreign languages built by the scripts. The script files may or may not have file extensions. The pen-ffi scripts should accept the following command line arguments. Argument Required Description -t <target> No Custom target triple of builds One of examples in practice is a pen-ffi.sh file in the Core library .","title":"Building libraries of foreign languages"},{"location":"advanced-features/ffi/#native-calling-convention-in-pen","text":"TBD","title":"Native calling convention in Pen"},{"location":"advanced-features/writing-system-packages/","text":"Writing system packages Using existing system packages covers most use cases in application development. However, by writing your own system packages, you can achieve the following: Define your own system interfaces of functions and types with side effects. Link applications in arbitrary file formats. This page assumes that you have already read Packages . Caveat: Providing bad system packages which do not conform to conventions can break the ecosystem of the language! In the worst cases, they might make applications malfunction. Please be careful to follow the conventions to keep applications maintainable and portable. Functionalities of system packages System packages have the following functionalities: Define context types. Provide system interfaces as functions and types. Link application files. Defining context types Every system package must have a module named Context at the top level. The module defines a Context type and an UnsafeNew function that returns a Context value with no argument. For example, a system package for command line applications might have the following Context module: ... type Context { print \\(string) none } UnsafeNew = \\() Context { Context{ print: ... } } The language's compiler uses these type and function to compose a context type passed to main functions in main modules in application packages. Providing system functions and types System packages are the only places where you can define functions that have side effects. Thanks to system packages, applications can perform effects to interact with the world, such as: Console input/output File system operations Networking Random number generation Note that system packages should never expose side effects directly through their functions ; all public functions in system packages must be purely functional. Instead, you need to pass a Context type to every effect-ful function for it to make side effects. For example, a system package for command line applications might have the following types and functions: # Define a foreign function to output a string in console. import foreign _pen_cli_print \\(string) none type Context { print: _pen_cli_print, } Print = \\(ctx Context, s string) none { ctx.print(s) } rather than: import foreign _pen_cli_print \\(string) none Print = \\(s string) none { # Oh, no! We make side effects in a public function directly. _pen_cli_print(s) } Linking application files (optional) System packages might have optional script files named pen-link at their top directories. On every build of application packages using the system packages, the script files run given object files specified as command line arguments to link application files. The script files may or may not have file extensions. The scripts should accept the following command line arguments. Argument Required Description -t <target> No Target triple -o <application> Yes Path of an application file <archive>... Yes Paths of archive files sorted topologically from main packages At the liking phase, compiled main functions are available under a symbol named _pen_main with Pen's native calling convention. Examples The Os standard package is an example of system packages.","title":"Writing system packages"},{"location":"advanced-features/writing-system-packages/#writing-system-packages","text":"Using existing system packages covers most use cases in application development. However, by writing your own system packages, you can achieve the following: Define your own system interfaces of functions and types with side effects. Link applications in arbitrary file formats. This page assumes that you have already read Packages . Caveat: Providing bad system packages which do not conform to conventions can break the ecosystem of the language! In the worst cases, they might make applications malfunction. Please be careful to follow the conventions to keep applications maintainable and portable.","title":"Writing system packages"},{"location":"advanced-features/writing-system-packages/#functionalities-of-system-packages","text":"System packages have the following functionalities: Define context types. Provide system interfaces as functions and types. Link application files.","title":"Functionalities of system packages"},{"location":"advanced-features/writing-system-packages/#defining-context-types","text":"Every system package must have a module named Context at the top level. The module defines a Context type and an UnsafeNew function that returns a Context value with no argument. For example, a system package for command line applications might have the following Context module: ... type Context { print \\(string) none } UnsafeNew = \\() Context { Context{ print: ... } } The language's compiler uses these type and function to compose a context type passed to main functions in main modules in application packages.","title":"Defining context types"},{"location":"advanced-features/writing-system-packages/#providing-system-functions-and-types","text":"System packages are the only places where you can define functions that have side effects. Thanks to system packages, applications can perform effects to interact with the world, such as: Console input/output File system operations Networking Random number generation Note that system packages should never expose side effects directly through their functions ; all public functions in system packages must be purely functional. Instead, you need to pass a Context type to every effect-ful function for it to make side effects. For example, a system package for command line applications might have the following types and functions: # Define a foreign function to output a string in console. import foreign _pen_cli_print \\(string) none type Context { print: _pen_cli_print, } Print = \\(ctx Context, s string) none { ctx.print(s) } rather than: import foreign _pen_cli_print \\(string) none Print = \\(s string) none { # Oh, no! We make side effects in a public function directly. _pen_cli_print(s) }","title":"Providing system functions and types"},{"location":"advanced-features/writing-system-packages/#linking-application-files-optional","text":"System packages might have optional script files named pen-link at their top directories. On every build of application packages using the system packages, the script files run given object files specified as command line arguments to link application files. The script files may or may not have file extensions. The scripts should accept the following command line arguments. Argument Required Description -t <target> No Target triple -o <application> Yes Path of an application file <archive>... Yes Paths of archive files sorted topologically from main packages At the liking phase, compiled main functions are available under a symbol named _pen_main with Pen's native calling convention.","title":"Linking application files (optional)"},{"location":"advanced-features/writing-system-packages/#examples","text":"The Os standard package is an example of system packages.","title":"Examples"},{"location":"examples/ffi/","text":"FFI Background Given a file named \"pen.json\" with: { \"type\": \"library\", \"dependencies\": {} } Import a foreign function of native calling convention Given a file named \"Foo.pen\" with: import foreign g \\(number) number f = \\(x number) number { g(x) } When I run pen build Then the exit status should be 0. Import a foreign function of the C calling convention Given a file named \"Foo.pen\" with: import foreign \"c\" g \\(number) number f = \\(x number) number { g(x) } When I run pen build Then the exit status should be 0. Export a foreign function Given a file named \"Foo.pen\" with: foreign f = \\(x number) number { x } When I run pen build Then the exit status should be 0. Export a foreign function of the C calling convention Given a file named \"Foo.pen\" with: foreign \"c\" f = \\(x number) number { x } When I run pen build Then the exit status should be 0.","title":"FFI"},{"location":"examples/ffi/#ffi","text":"","title":"FFI"},{"location":"examples/ffi/#background","text":"Given a file named \"pen.json\" with: { \"type\": \"library\", \"dependencies\": {} }","title":"Background"},{"location":"examples/ffi/#import-a-foreign-function-of-native-calling-convention","text":"Given a file named \"Foo.pen\" with: import foreign g \\(number) number f = \\(x number) number { g(x) } When I run pen build Then the exit status should be 0.","title":"Import a foreign function of native calling convention"},{"location":"examples/ffi/#import-a-foreign-function-of-the-c-calling-convention","text":"Given a file named \"Foo.pen\" with: import foreign \"c\" g \\(number) number f = \\(x number) number { g(x) } When I run pen build Then the exit status should be 0.","title":"Import a foreign function of the C calling convention"},{"location":"examples/ffi/#export-a-foreign-function","text":"Given a file named \"Foo.pen\" with: foreign f = \\(x number) number { x } When I run pen build Then the exit status should be 0.","title":"Export a foreign function"},{"location":"examples/ffi/#export-a-foreign-function-of-the-c-calling-convention","text":"Given a file named \"Foo.pen\" with: foreign \"c\" f = \\(x number) number { x } When I run pen build Then the exit status should be 0.","title":"Export a foreign function of the C calling convention"},{"location":"examples/module/","text":"Modules Background Given a file named \"pen.json\" with: { \"type\": \"library\", \"dependencies\": {} } Import a function from a module Given a file named \"Foo.pen\" with: Foo = \\() number { 42 } And a file named \"Bar.pen\" with: import 'Foo Bar = \\() number { Foo'Foo() } When I run pen build Then the exit status should be 0. Import a type alias from a module Given a file named \"Foo.pen\" with: type Foo = number And a file named \"Bar.pen\" with: import 'Foo type Bar = Foo'Foo When I run pen build Then the exit status should be 0. Import a function from a nested module Given a file named \"Foo/Foo.pen\" with: Foo = \\() number { 42 } And a file named \"Bar.pen\" with: import 'Foo'Foo Bar = \\() number { Foo'Foo() } When I run pen build Then the exit status should be 0. Import a module with a custom prefix Given a file named \"Foo.pen\" with: Foo = \\() number { 42 } And a file named \"Bar.pen\" with: import 'Foo as Bar Bar = \\() number { Bar'Foo() } When I run pen build Then the exit status should be 0. Import a type definition with no prefix Given a file named \"Foo.pen\" with: type Foo {} And a file named \"Bar.pen\" with: import 'Foo { Foo } type Bar = Foo When I run pen build Then the exit status should be 0. Import a type alias with no prefix Given a file named \"Foo.pen\" with: type Foo = number And a file named \"Bar.pen\" with: import 'Foo { Foo } type Bar = Foo When I run pen build Then the exit status should be 0. Import a function with no prefix Given a file named \"Foo.pen\" with: Foo = \\() number { 42 } And a file named \"Bar.pen\" with: import 'Foo { Foo } Bar = \\() number { Foo() } When I run pen build Then the exit status should be 0.","title":"Modules"},{"location":"examples/module/#modules","text":"","title":"Modules"},{"location":"examples/module/#background","text":"Given a file named \"pen.json\" with: { \"type\": \"library\", \"dependencies\": {} }","title":"Background"},{"location":"examples/module/#import-a-function-from-a-module","text":"Given a file named \"Foo.pen\" with: Foo = \\() number { 42 } And a file named \"Bar.pen\" with: import 'Foo Bar = \\() number { Foo'Foo() } When I run pen build Then the exit status should be 0.","title":"Import a function from a module"},{"location":"examples/module/#import-a-type-alias-from-a-module","text":"Given a file named \"Foo.pen\" with: type Foo = number And a file named \"Bar.pen\" with: import 'Foo type Bar = Foo'Foo When I run pen build Then the exit status should be 0.","title":"Import a type alias from a module"},{"location":"examples/module/#import-a-function-from-a-nested-module","text":"Given a file named \"Foo/Foo.pen\" with: Foo = \\() number { 42 } And a file named \"Bar.pen\" with: import 'Foo'Foo Bar = \\() number { Foo'Foo() } When I run pen build Then the exit status should be 0.","title":"Import a function from a nested module"},{"location":"examples/module/#import-a-module-with-a-custom-prefix","text":"Given a file named \"Foo.pen\" with: Foo = \\() number { 42 } And a file named \"Bar.pen\" with: import 'Foo as Bar Bar = \\() number { Bar'Foo() } When I run pen build Then the exit status should be 0.","title":"Import a module with a custom prefix"},{"location":"examples/module/#import-a-type-definition-with-no-prefix","text":"Given a file named \"Foo.pen\" with: type Foo {} And a file named \"Bar.pen\" with: import 'Foo { Foo } type Bar = Foo When I run pen build Then the exit status should be 0.","title":"Import a type definition with no prefix"},{"location":"examples/module/#import-a-type-alias-with-no-prefix","text":"Given a file named \"Foo.pen\" with: type Foo = number And a file named \"Bar.pen\" with: import 'Foo { Foo } type Bar = Foo When I run pen build Then the exit status should be 0.","title":"Import a type alias with no prefix"},{"location":"examples/module/#import-a-function-with-no-prefix","text":"Given a file named \"Foo.pen\" with: Foo = \\() number { 42 } And a file named \"Bar.pen\" with: import 'Foo { Foo } Bar = \\() number { Foo() } When I run pen build Then the exit status should be 0.","title":"Import a function with no prefix"},{"location":"examples/package/","text":"Packages Background Given a file named \"foo/pen.json\" with: { \"type\": \"library\", \"dependencies\": {} } And a file named \"foo/Foo.pen\" with: type Foo = number Foo = \\() number { 42 } And a file named \"foo/Foo/Foo.pen\" with: Foo = \\() number { 42 } And a directory named \"bar\" And I cd to \"bar\" And a file named \"pen.json\" with: { \"type\": \"library\", \"dependencies\": { \"Foo\": \"../foo\" } } Import a function from a module Given a file named \"Bar.pen\" with: import Foo'Foo Bar = \\() number { Foo'Foo() } When I run pen build Then the exit status should be 0. Import a type from a module Given a file named \"Bar.pen\" with: import Foo'Foo type Bar = Foo'Foo When I run pen build Then the exit status should be 0. Import a function from a nested module Given a file named \"Bar.pen\" with: import Foo'Foo'Foo Bar = \\() number { Foo'Foo() } When I run pen build Then the exit status should be 0.","title":"Packages"},{"location":"examples/package/#packages","text":"","title":"Packages"},{"location":"examples/package/#background","text":"Given a file named \"foo/pen.json\" with: { \"type\": \"library\", \"dependencies\": {} } And a file named \"foo/Foo.pen\" with: type Foo = number Foo = \\() number { 42 } And a file named \"foo/Foo/Foo.pen\" with: Foo = \\() number { 42 } And a directory named \"bar\" And I cd to \"bar\" And a file named \"pen.json\" with: { \"type\": \"library\", \"dependencies\": { \"Foo\": \"../foo\" } }","title":"Background"},{"location":"examples/package/#import-a-function-from-a-module","text":"Given a file named \"Bar.pen\" with: import Foo'Foo Bar = \\() number { Foo'Foo() } When I run pen build Then the exit status should be 0.","title":"Import a function from a module"},{"location":"examples/package/#import-a-type-from-a-module","text":"Given a file named \"Bar.pen\" with: import Foo'Foo type Bar = Foo'Foo When I run pen build Then the exit status should be 0.","title":"Import a type from a module"},{"location":"examples/package/#import-a-function-from-a-nested-module","text":"Given a file named \"Bar.pen\" with: import Foo'Foo'Foo Bar = \\() number { Foo'Foo() } When I run pen build Then the exit status should be 0.","title":"Import a function from a nested module"},{"location":"examples/commands/build/","text":"Building packages Build an application package Given a file named \"pen.json\" with: { \"type\": \"application\", \"dependencies\": { \"Os\": \"pen:///os\" } } And a file named \"main.pen\" with: import Os'Context { Context } main = \\(ctx context) none { none } When I successfully run pen build Then I successfully run ./app . Build a library package Given a file named \"pen.json\" with: { \"type\": \"library\", \"dependencies\": {} } And a file named \"Foo.pen\" with: f = \\(x number) number { x } When I run pen build Then the exit status should be 0. Cross-build an application package Given a file named \"pen.json\" with: { \"type\": \"application\", \"dependencies\": { \"Os\": \"pen:///os-sync\" } } And a file named \"main.pen\" with: import Os'Context { Context } main = \\(ctx context) none { none } And I successfully run rustup target add <target> When I successfully run pen build --target <target> Then the exit status should be 0. Examples target i686-unknown-linux-musl x86_64-unknown-linux-musl aarch64-unknown-linux-musl wasm32-wasi Cross-build a library package Given a file named \"pen.json\" with: { \"type\": \"library\", \"dependencies\": {} } And a file named \"Foo.pen\" with: f = \\(x number) number { x } And I successfully run rustup target add <target> When I successfully run pen build --target <target> Then the exit status should be 0. Examples target i686-unknown-linux-musl x86_64-unknown-linux-musl aarch64-unknown-linux-musl wasm32-wasi Build an application package again Given a file named \"pen.json\" with: { \"type\": \"application\", \"dependencies\": { \"Os\": \"pen:///os\" } } And a file named \"main.pen\" with: import Os'Context { Context } main = \\(ctx context) none { none } And I successfully run pen build And I successfully run ./app And the stdout from \"./app\" should contain exactly \"\" When a file named \"main.pen\" with: import Os'Context { Context } import Os'File main = \\(ctx context) none { _ = File'Write(ctx.Os, File'StdOut(), \"hello\") none } And I successfully run pen build Then I successfully run ./app And the stdout from \"./app\" should contain exactly \"hello\".","title":"Building packages"},{"location":"examples/commands/build/#building-packages","text":"","title":"Building packages"},{"location":"examples/commands/build/#build-an-application-package","text":"Given a file named \"pen.json\" with: { \"type\": \"application\", \"dependencies\": { \"Os\": \"pen:///os\" } } And a file named \"main.pen\" with: import Os'Context { Context } main = \\(ctx context) none { none } When I successfully run pen build Then I successfully run ./app .","title":"Build an application package"},{"location":"examples/commands/build/#build-a-library-package","text":"Given a file named \"pen.json\" with: { \"type\": \"library\", \"dependencies\": {} } And a file named \"Foo.pen\" with: f = \\(x number) number { x } When I run pen build Then the exit status should be 0.","title":"Build a library package"},{"location":"examples/commands/build/#cross-build-an-application-package","text":"Given a file named \"pen.json\" with: { \"type\": \"application\", \"dependencies\": { \"Os\": \"pen:///os-sync\" } } And a file named \"main.pen\" with: import Os'Context { Context } main = \\(ctx context) none { none } And I successfully run rustup target add <target> When I successfully run pen build --target <target> Then the exit status should be 0.","title":"Cross-build an application package"},{"location":"examples/commands/build/#examples","text":"target i686-unknown-linux-musl x86_64-unknown-linux-musl aarch64-unknown-linux-musl wasm32-wasi","title":"Examples"},{"location":"examples/commands/build/#cross-build-a-library-package","text":"Given a file named \"pen.json\" with: { \"type\": \"library\", \"dependencies\": {} } And a file named \"Foo.pen\" with: f = \\(x number) number { x } And I successfully run rustup target add <target> When I successfully run pen build --target <target> Then the exit status should be 0.","title":"Cross-build a library package"},{"location":"examples/commands/build/#examples_1","text":"target i686-unknown-linux-musl x86_64-unknown-linux-musl aarch64-unknown-linux-musl wasm32-wasi","title":"Examples"},{"location":"examples/commands/build/#build-an-application-package-again","text":"Given a file named \"pen.json\" with: { \"type\": \"application\", \"dependencies\": { \"Os\": \"pen:///os\" } } And a file named \"main.pen\" with: import Os'Context { Context } main = \\(ctx context) none { none } And I successfully run pen build And I successfully run ./app And the stdout from \"./app\" should contain exactly \"\" When a file named \"main.pen\" with: import Os'Context { Context } import Os'File main = \\(ctx context) none { _ = File'Write(ctx.Os, File'StdOut(), \"hello\") none } And I successfully run pen build Then I successfully run ./app And the stdout from \"./app\" should contain exactly \"hello\".","title":"Build an application package again"},{"location":"examples/commands/create/","text":"Creating packages Create an application package Given I successfully run pen create foo And I cd to \"foo\" When I successfully run pen build Then I successfully run ./app . Create a library package Given I successfully run pen create --library foo And I cd to \"foo\" When I run pen build Then the exit status should be 0. Create an application package in a current directory Given I successfully run pen create . When I successfully run pen build Then I successfully run ./app . Create a library package in a current directory Given I successfully run pen create --library . When I run pen build Then the exit status should be 0.","title":"Creating packages"},{"location":"examples/commands/create/#creating-packages","text":"","title":"Creating packages"},{"location":"examples/commands/create/#create-an-application-package","text":"Given I successfully run pen create foo And I cd to \"foo\" When I successfully run pen build Then I successfully run ./app .","title":"Create an application package"},{"location":"examples/commands/create/#create-a-library-package","text":"Given I successfully run pen create --library foo And I cd to \"foo\" When I run pen build Then the exit status should be 0.","title":"Create a library package"},{"location":"examples/commands/create/#create-an-application-package-in-a-current-directory","text":"Given I successfully run pen create . When I successfully run pen build Then I successfully run ./app .","title":"Create an application package in a current directory"},{"location":"examples/commands/create/#create-a-library-package-in-a-current-directory","text":"Given I successfully run pen create --library . When I run pen build Then the exit status should be 0.","title":"Create a library package in a current directory"},{"location":"examples/commands/document/","text":"Generating documentation for a package Background Given a file named \"pen.json\" with: { \"type\": \"library\", \"dependencies\": {} } Generate documentation for a package Given a file named \"Foo.pen\" with: # Do something nice. Foo = \\() none { none } When I run the following script: pen document \\ --name Foo \\ --url https://github.com/foo/foo \\ --description \"This package is cool.\" \\ > Foo.md Then a file named \"Foo.md\" should contain \" Foo package\".","title":"Generating documentation for a package"},{"location":"examples/commands/document/#generating-documentation-for-a-package","text":"","title":"Generating documentation for a package"},{"location":"examples/commands/document/#background","text":"Given a file named \"pen.json\" with: { \"type\": \"library\", \"dependencies\": {} }","title":"Background"},{"location":"examples/commands/document/#generate-documentation-for-a-package","text":"Given a file named \"Foo.pen\" with: # Do something nice. Foo = \\() none { none } When I run the following script: pen document \\ --name Foo \\ --url https://github.com/foo/foo \\ --description \"This package is cool.\" \\ > Foo.md Then a file named \"Foo.md\" should contain \" Foo package\".","title":"Generate documentation for a package"},{"location":"examples/commands/format/","text":"Formatting module files Background Given a file named \"pen.json\" with: { \"type\": \"library\", \"dependencies\": {} } Format module files Given a file named \"Foo.pen\" with: Foo = \\() none { none } When I successfully run pen format Then a file named \"Foo.pen\" should contain exactly: Foo = \\() none { none } Check if module files are formatted Given a file named \"Foo.pen\" with: Foo = \\() none { none } When I run pen format --checked Then the exit status should not be 0.","title":"Formatting module files"},{"location":"examples/commands/format/#formatting-module-files","text":"","title":"Formatting module files"},{"location":"examples/commands/format/#background","text":"Given a file named \"pen.json\" with: { \"type\": \"library\", \"dependencies\": {} }","title":"Background"},{"location":"examples/commands/format/#format-module-files","text":"Given a file named \"Foo.pen\" with: Foo = \\() none { none } When I successfully run pen format Then a file named \"Foo.pen\" should contain exactly: Foo = \\() none { none }","title":"Format module files"},{"location":"examples/commands/format/#check-if-module-files-are-formatted","text":"Given a file named \"Foo.pen\" with: Foo = \\() none { none } When I run pen format --checked Then the exit status should not be 0.","title":"Check if module files are formatted"},{"location":"examples/commands/test/","text":"Testing packages Background Given a file named \"pen.json\" with: { \"type\": \"library\", \"dependencies\": { \"Test\": \"pen:///test\" } } And a file named \"Foo.pen\" with: Add = \\(x number, y number) number { x + y } Test a module Given a file named \"Foo.test.pen\" with: import Test'Assert import 'Foo Add = \\() none | error { Assert'Equal(Foo'Add(41, 1), 42) } When I run pen test Then the exit status should be 0 And the stdout should contain \"OK\". Fail to test a module Given a file named \"Foo.test.pen\" with: import Test'Assert import 'Foo Add = \\() none | error { Assert'Equal(Foo'Add(41, 0), 42) } When I run pen test Then the exit status should not be 0 And the stdout should contain \"FAIL\". Run multiple tests Given a file named \"Foo.test.pen\" with: import Test'Assert import 'Foo Add = \\() none | error { Assert'Equal(Foo'Add(41, 1), 42) } AddMore = \\() none | error { Assert'Equal(Foo'Add(40, 2), 42) } When I successfully run pen test Then the exit status should be 0. Run no test When I run pen test Then the exit status should be 0. Use a debug function in a test Given a file named \"Foo.test.pen\" with: Foo = \\() none | error { debug(\"hello\") } When I run pen test Then the exit status should be 0.","title":"Testing packages"},{"location":"examples/commands/test/#testing-packages","text":"","title":"Testing packages"},{"location":"examples/commands/test/#background","text":"Given a file named \"pen.json\" with: { \"type\": \"library\", \"dependencies\": { \"Test\": \"pen:///test\" } } And a file named \"Foo.pen\" with: Add = \\(x number, y number) number { x + y }","title":"Background"},{"location":"examples/commands/test/#test-a-module","text":"Given a file named \"Foo.test.pen\" with: import Test'Assert import 'Foo Add = \\() none | error { Assert'Equal(Foo'Add(41, 1), 42) } When I run pen test Then the exit status should be 0 And the stdout should contain \"OK\".","title":"Test a module"},{"location":"examples/commands/test/#fail-to-test-a-module","text":"Given a file named \"Foo.test.pen\" with: import Test'Assert import 'Foo Add = \\() none | error { Assert'Equal(Foo'Add(41, 0), 42) } When I run pen test Then the exit status should not be 0 And the stdout should contain \"FAIL\".","title":"Fail to test a module"},{"location":"examples/commands/test/#run-multiple-tests","text":"Given a file named \"Foo.test.pen\" with: import Test'Assert import 'Foo Add = \\() none | error { Assert'Equal(Foo'Add(41, 1), 42) } AddMore = \\() none | error { Assert'Equal(Foo'Add(40, 2), 42) } When I successfully run pen test Then the exit status should be 0.","title":"Run multiple tests"},{"location":"examples/commands/test/#run-no-test","text":"When I run pen test Then the exit status should be 0.","title":"Run no test"},{"location":"examples/commands/test/#use-a-debug-function-in-a-test","text":"Given a file named \"Foo.test.pen\" with: Foo = \\() none | error { debug(\"hello\") } When I run pen test Then the exit status should be 0.","title":"Use a debug function in a test"},{"location":"examples/smoke/built-ins/","text":"Built-ins Background Given a file named \"pen.json\" with: { \"type\": \"application\", \"dependencies\": { \"Os\": \"pen:///os\" } } Print a value with a debug function Given a file named \"main.pen\" with: type foo {} type bar { x number } type baz { x number y string } main = \\(_ context) none { debug(<input>) } When I successfully run pen build Then I successfully run ./app And the stderr from \"./app\" should contain exactly ' ' Then I successfully run check_memory_leak.sh ./app . Examples input output false false true true none none \"foo\" \"foo\" 42 42 foo{} foo{} bar{x: 42} bar{x: 42} baz{x: 42, y: \"foo\"} baz{x: 42, y: \"foo\"} [number 42, 42] [number 42, 42] {string: number \"foo\": 1, \"bar\": 2} {string: number \"bar\": 2, \"foo\": 1} error(\"foo\") error(\"foo\") (x none) none { x }","title":"Built-ins"},{"location":"examples/smoke/built-ins/#built-ins","text":"","title":"Built-ins"},{"location":"examples/smoke/built-ins/#background","text":"Given a file named \"pen.json\" with: { \"type\": \"application\", \"dependencies\": { \"Os\": \"pen:///os\" } }","title":"Background"},{"location":"examples/smoke/built-ins/#print-a-value-with-a-debug-function","text":"Given a file named \"main.pen\" with: type foo {} type bar { x number } type baz { x number y string } main = \\(_ context) none { debug(<input>) } When I successfully run pen build Then I successfully run ./app And the stderr from \"./app\" should contain exactly ' ' Then I successfully run check_memory_leak.sh ./app .","title":"Print a value with a debug function"},{"location":"examples/smoke/built-ins/#examples","text":"input output false false true true none none \"foo\" \"foo\" 42 42 foo{} foo{} bar{x: 42} bar{x: 42} baz{x: 42, y: \"foo\"} baz{x: 42, y: \"foo\"} [number 42, 42] [number 42, 42] {string: number \"foo\": 1, \"bar\": 2} {string: number \"bar\": 2, \"foo\": 1} error(\"foo\") error(\"foo\") (x none) none { x }","title":"Examples"},{"location":"examples/smoke/examples/","text":"Examples Background Given I run the following script: cp -r $PEN_ROOT/examples . Build and test examples When I cd to \"examples/ \" Then I successfully run pen format --check And I successfully run pen build And I successfully run pen test . Examples example algorithms/fibonacci algorithms/fizz-buzz algorithms/knapsack algorithms/quick-sort algorithms/parallel/fibonacci cat console echo hello-world http-client http-server life-game ls snake sql-client tcp-client tcp-server udp-client udp-server yes Run HTTP client and server Given I cd to \"examples/http-server\" And I successfully run pen build And I run ./app in background When I cd to \"../http-client\" And I successfully run pen build Then I successfully run ./app get http://localhost:8080 hello And the stdout from \"./app get http://localhost:8080 hello\" should contain exactly \"hello\". Run TCP client and server Given I cd to \"examples/tcp-server\" And I successfully run pen build And I run ./app localhost:4242 in background When I cd to \"../tcp-client\" And I successfully run pen build Then I successfully run ./app localhost:4242 hello And the stdout from \"./app localhost:4242 hello\" should contain exactly \"hello\". Run UDP client and server Given I cd to \"examples/udp-server\" And I successfully run pen build And I run ./app localhost:4242 in background When I cd to \"../udp-client\" And I successfully run pen build Then I successfully run ./app localhost:4242 hello And the stdout from \"./app localhost:4242 hello\" should contain exactly \"hello\". Run SQL client Given I cd to \"examples/sql-client\" And I successfully run pen build And I successfully run sqlite3 foo.db 'create table foo (bar int)' When I successfully run pen build Then I successfully run ./app execute sqlite://foo.db 'insert into foo (bar) values (42)' And I successfully run ./app query sqlite://foo.db 'select * from foo' And the stdout from \"./app query sqlite://foo.db 'select * from foo'\" should contain exactly \"42\".","title":"Examples"},{"location":"examples/smoke/examples/#examples","text":"","title":"Examples"},{"location":"examples/smoke/examples/#background","text":"Given I run the following script: cp -r $PEN_ROOT/examples .","title":"Background"},{"location":"examples/smoke/examples/#build-and-test-examples","text":"When I cd to \"examples/ \" Then I successfully run pen format --check And I successfully run pen build And I successfully run pen test .","title":"Build and test examples"},{"location":"examples/smoke/examples/#examples_1","text":"example algorithms/fibonacci algorithms/fizz-buzz algorithms/knapsack algorithms/quick-sort algorithms/parallel/fibonacci cat console echo hello-world http-client http-server life-game ls snake sql-client tcp-client tcp-server udp-client udp-server yes","title":"Examples"},{"location":"examples/smoke/examples/#run-http-client-and-server","text":"Given I cd to \"examples/http-server\" And I successfully run pen build And I run ./app in background When I cd to \"../http-client\" And I successfully run pen build Then I successfully run ./app get http://localhost:8080 hello And the stdout from \"./app get http://localhost:8080 hello\" should contain exactly \"hello\".","title":"Run HTTP client and server"},{"location":"examples/smoke/examples/#run-tcp-client-and-server","text":"Given I cd to \"examples/tcp-server\" And I successfully run pen build And I run ./app localhost:4242 in background When I cd to \"../tcp-client\" And I successfully run pen build Then I successfully run ./app localhost:4242 hello And the stdout from \"./app localhost:4242 hello\" should contain exactly \"hello\".","title":"Run TCP client and server"},{"location":"examples/smoke/examples/#run-udp-client-and-server","text":"Given I cd to \"examples/udp-server\" And I successfully run pen build And I run ./app localhost:4242 in background When I cd to \"../udp-client\" And I successfully run pen build Then I successfully run ./app localhost:4242 hello And the stdout from \"./app localhost:4242 hello\" should contain exactly \"hello\".","title":"Run UDP client and server"},{"location":"examples/smoke/examples/#run-sql-client","text":"Given I cd to \"examples/sql-client\" And I successfully run pen build And I successfully run sqlite3 foo.db 'create table foo (bar int)' When I successfully run pen build Then I successfully run ./app execute sqlite://foo.db 'insert into foo (bar) values (42)' And I successfully run ./app query sqlite://foo.db 'select * from foo' And the stdout from \"./app query sqlite://foo.db 'select * from foo'\" should contain exactly \"42\".","title":"Run SQL client"},{"location":"examples/smoke/module/","text":"Modules Background Given a file named \"pen.json\" with: { \"type\": \"library\", \"dependencies\": {} } Import a duplicate name Given a file named \"foo.pen\" with: Foo = \\(x number) number { x } And a file named \"bar.pen\" with: import 'foo { Foo } Foo = \\() none { Foo() } When I successfully run pen build Then the exit status should be 0. Compare a type imported indirectly Given a file named \"foo.pen\" with: type Foo {} And a file named \"bar.pen\" with: import 'foo { Foo } type Bar { xs [Foo] } And a file named \"baz.pen\" with: import 'bar { Bar } type Baz = Bar When I successfully run pen build Then the exit status should be 0. Import an undefined name Given a file named \"foo.pen\" with: And a file named \"bar.pen\" with: import 'foo { tomato } When I run pen build Then the exit status should not be 0.","title":"Modules"},{"location":"examples/smoke/module/#modules","text":"","title":"Modules"},{"location":"examples/smoke/module/#background","text":"Given a file named \"pen.json\" with: { \"type\": \"library\", \"dependencies\": {} }","title":"Background"},{"location":"examples/smoke/module/#import-a-duplicate-name","text":"Given a file named \"foo.pen\" with: Foo = \\(x number) number { x } And a file named \"bar.pen\" with: import 'foo { Foo } Foo = \\() none { Foo() } When I successfully run pen build Then the exit status should be 0.","title":"Import a duplicate name"},{"location":"examples/smoke/module/#compare-a-type-imported-indirectly","text":"Given a file named \"foo.pen\" with: type Foo {} And a file named \"bar.pen\" with: import 'foo { Foo } type Bar { xs [Foo] } And a file named \"baz.pen\" with: import 'bar { Bar } type Baz = Bar When I successfully run pen build Then the exit status should be 0.","title":"Compare a type imported indirectly"},{"location":"examples/smoke/module/#import-an-undefined-name","text":"Given a file named \"foo.pen\" with: And a file named \"bar.pen\" with: import 'foo { tomato } When I run pen build Then the exit status should not be 0.","title":"Import an undefined name"},{"location":"examples/smoke/os/","text":"OS Background Given a file named \"pen.json\" with: { \"type\": \"application\", \"dependencies\": { \"Os\": \"pen:///os\", \"Core\": \"pen:///core\" } } Read and write files Given a file named \"main.pen\" with: import Os'Context { Context } import Os'File import Os'File'OpenOptions { OpenOptions } import Os'Process main = \\(ctx context) none { if _ = run(ctx.Os) as none { none } else { Process'Exit(ctx.Os, 1) } } run = \\(ctx Context) none | error { f = File'Open(ctx, \"foo.txt\")? d = File'Read(ctx, f)? f = File'OpenWithOptions( ctx, \"bar.txt\", OpenOptions{ ...OpenOptions'Default(), Create: true, Write: true, }, )? File'Write(ctx, f, d)? none } And a file named \"foo.txt\" with \"foo\" When I successfully run pen build Then I successfully run ./app And the file \"bar.txt\" should contain \"foo\". Read a file until a limit Given a file named \"main.pen\" with: import Os'Context { Context } import Os'File import Os'Process main = \\(ctx context) none { if _ = run(ctx.Os) as none { none } else { Process'Exit(ctx.Os, 1) } } run = \\(ctx Context) none | error { f = File'Open(ctx, \"foo.txt\")? d = File'ReadLimit(ctx, f, 5)? File'Write(ctx, File'StdOut(), d)? none } And a file named \"foo.txt\" with \"Hello, world!\" When I successfully run pen build Then I successfully run ./app And the stdout from \"./app\" should contain exactly \"Hello\". Read a directory Given a file named \"main.pen\" with: import Core'String import Os'Context { Context } import Os'File import Os'Directory import Os'Process main = \\(ctx context) none { if _ = run(ctx.Os) as none { none } else { Process'Exit(ctx.Os, 1) } } run = \\(ctx Context) none | error { File'Write( ctx, File'StdOut(), String'Join(Directory'Read(ctx, \".\")?, \"\\n\"), )? none } When I successfully run pen build Then I successfully run ./app And the stdout from \"./app\" should contain \"main.pen\" And the stdout from \"./app\" should contain \"pen.json\". Use go syntax Given a file named \"main.pen\" with: import Os'Context { Context } main = \\(ctx context) none { f = go(\\() none { none }) f() } When I successfully run pen build Then I successfully run check_memory_leak.sh ./app .","title":"OS"},{"location":"examples/smoke/os/#os","text":"","title":"OS"},{"location":"examples/smoke/os/#background","text":"Given a file named \"pen.json\" with: { \"type\": \"application\", \"dependencies\": { \"Os\": \"pen:///os\", \"Core\": \"pen:///core\" } }","title":"Background"},{"location":"examples/smoke/os/#read-and-write-files","text":"Given a file named \"main.pen\" with: import Os'Context { Context } import Os'File import Os'File'OpenOptions { OpenOptions } import Os'Process main = \\(ctx context) none { if _ = run(ctx.Os) as none { none } else { Process'Exit(ctx.Os, 1) } } run = \\(ctx Context) none | error { f = File'Open(ctx, \"foo.txt\")? d = File'Read(ctx, f)? f = File'OpenWithOptions( ctx, \"bar.txt\", OpenOptions{ ...OpenOptions'Default(), Create: true, Write: true, }, )? File'Write(ctx, f, d)? none } And a file named \"foo.txt\" with \"foo\" When I successfully run pen build Then I successfully run ./app And the file \"bar.txt\" should contain \"foo\".","title":"Read and write files"},{"location":"examples/smoke/os/#read-a-file-until-a-limit","text":"Given a file named \"main.pen\" with: import Os'Context { Context } import Os'File import Os'Process main = \\(ctx context) none { if _ = run(ctx.Os) as none { none } else { Process'Exit(ctx.Os, 1) } } run = \\(ctx Context) none | error { f = File'Open(ctx, \"foo.txt\")? d = File'ReadLimit(ctx, f, 5)? File'Write(ctx, File'StdOut(), d)? none } And a file named \"foo.txt\" with \"Hello, world!\" When I successfully run pen build Then I successfully run ./app And the stdout from \"./app\" should contain exactly \"Hello\".","title":"Read a file until a limit"},{"location":"examples/smoke/os/#read-a-directory","text":"Given a file named \"main.pen\" with: import Core'String import Os'Context { Context } import Os'File import Os'Directory import Os'Process main = \\(ctx context) none { if _ = run(ctx.Os) as none { none } else { Process'Exit(ctx.Os, 1) } } run = \\(ctx Context) none | error { File'Write( ctx, File'StdOut(), String'Join(Directory'Read(ctx, \".\")?, \"\\n\"), )? none } When I successfully run pen build Then I successfully run ./app And the stdout from \"./app\" should contain \"main.pen\" And the stdout from \"./app\" should contain \"pen.json\".","title":"Read a directory"},{"location":"examples/smoke/os/#use-go-syntax","text":"Given a file named \"main.pen\" with: import Os'Context { Context } main = \\(ctx context) none { f = go(\\() none { none }) f() } When I successfully run pen build Then I successfully run check_memory_leak.sh ./app .","title":"Use go syntax"},{"location":"examples/smoke/standard-packages/","text":"Standard packages Build and test standard packages Given I run the following script: cp -r $PEN_ROOT/packages . When I cd to \"packages/ \" Then I successfully run pen format --check And I successfully run pen build And I successfully run pen test . Examples package core flag html http json os os-sync random reflect regex sql test","title":"Standard packages"},{"location":"examples/smoke/standard-packages/#standard-packages","text":"","title":"Standard packages"},{"location":"examples/smoke/standard-packages/#build-and-test-standard-packages","text":"Given I run the following script: cp -r $PEN_ROOT/packages . When I cd to \"packages/ \" Then I successfully run pen format --check And I successfully run pen build And I successfully run pen test .","title":"Build and test standard packages"},{"location":"examples/smoke/standard-packages/#examples","text":"package core flag html http json os os-sync random reflect regex sql test","title":"Examples"},{"location":"examples/smoke/syntax/","text":"Syntax Background Given a file named \"pen.json\" with: { \"type\": \"library\", \"dependencies\": {} } Override a built-in function Given a file named \"Foo.pen\" with: go = \\() none { none } foo = \\() none { go() } When I successfully run pen build Then the exit status should be 0. Override a built-in type with a type definition Given a file named \"Foo.pen\" with: type none { x number } foo = \\() none { none{x: 42} } When I successfully run pen build Then the exit status should be 0. Override a built-in type with a type alias Given a file named \"Foo.pen\" with: type none = number foo = \\() none { 0 } When I successfully run pen build Then the exit status should be 0.","title":"Syntax"},{"location":"examples/smoke/syntax/#syntax","text":"","title":"Syntax"},{"location":"examples/smoke/syntax/#background","text":"Given a file named \"pen.json\" with: { \"type\": \"library\", \"dependencies\": {} }","title":"Background"},{"location":"examples/smoke/syntax/#override-a-built-in-function","text":"Given a file named \"Foo.pen\" with: go = \\() none { none } foo = \\() none { go() } When I successfully run pen build Then the exit status should be 0.","title":"Override a built-in function"},{"location":"examples/smoke/syntax/#override-a-built-in-type-with-a-type-definition","text":"Given a file named \"Foo.pen\" with: type none { x number } foo = \\() none { none{x: 42} } When I successfully run pen build Then the exit status should be 0.","title":"Override a built-in type with a type definition"},{"location":"examples/smoke/syntax/#override-a-built-in-type-with-a-type-alias","text":"Given a file named \"Foo.pen\" with: type none = number foo = \\() none { 0 } When I successfully run pen build Then the exit status should be 0.","title":"Override a built-in type with a type alias"},{"location":"examples/smoke/test-packages/","text":"Test packages Build and test test packages Given I run the following script: cp -r $PEN_ROOT/test . When I cd to \"test/ \" Then I successfully run pen format --check And I successfully run pen build And I successfully run pen test . Examples package prelude reflect","title":"Test packages"},{"location":"examples/smoke/test-packages/#test-packages","text":"","title":"Test packages"},{"location":"examples/smoke/test-packages/#build-and-test-test-packages","text":"Given I run the following script: cp -r $PEN_ROOT/test . When I cd to \"test/ \" Then I successfully run pen format --check And I successfully run pen build And I successfully run pen test .","title":"Build and test test packages"},{"location":"examples/smoke/test-packages/#examples","text":"package prelude reflect","title":"Examples"},{"location":"examples/smoke/test/","text":"Testing Background Given a file named \"pen.json\" with: { \"type\": \"library\", \"dependencies\": { \"Test\": \"pen:///test\" } } And a file named \"Foo.pen\" with: Add = \\(x number, y number) number { x + y } Run a test referencing an Os package Given a file named \"pen.json\" with: { \"type\": \"application\", \"dependencies\": { \"Os\": \"pen:///os\", \"Test\": \"pen:///test\" } } And a file named \"main.pen\" with: import Os'Context { Context } main = \\(ctx context) none { none } And a file named \"main.test.pen\" with: import Os'File Foo = \\() none | error { _ = File'Write none } When I successfully run pen test Then the exit status should be 0. Run tests without a Test package Given a file named \"pen.json\" with: { \"type\": \"library\", \"dependencies\": {} } And a file named \"Foo.test.pen\" with: import 'Foo Add = \\() none | error { if Foo'Add(41, 1) == 42 { none } else { error(\"oh no\") } } When I successfully run pen test Then the exit status should be 0. Keep an application file on testing Given a file named \"pen.json\" with: { \"type\": \"application\", \"dependencies\": { \"Os\": \"pen:///os\", \"Test\": \"pen:///test\" } } And a file named \"main.pen\" with: import Os'Context { Context } main = \\(ctx context) none { none } And a file named \"main.test.pen\" with: Foo = \\() none | error { none } And I successfully run pen build When I successfully run pen test Then I successfully run ./app .","title":"Testing"},{"location":"examples/smoke/test/#testing","text":"","title":"Testing"},{"location":"examples/smoke/test/#background","text":"Given a file named \"pen.json\" with: { \"type\": \"library\", \"dependencies\": { \"Test\": \"pen:///test\" } } And a file named \"Foo.pen\" with: Add = \\(x number, y number) number { x + y }","title":"Background"},{"location":"examples/smoke/test/#run-a-test-referencing-an-os-package","text":"Given a file named \"pen.json\" with: { \"type\": \"application\", \"dependencies\": { \"Os\": \"pen:///os\", \"Test\": \"pen:///test\" } } And a file named \"main.pen\" with: import Os'Context { Context } main = \\(ctx context) none { none } And a file named \"main.test.pen\" with: import Os'File Foo = \\() none | error { _ = File'Write none } When I successfully run pen test Then the exit status should be 0.","title":"Run a test referencing an Os package"},{"location":"examples/smoke/test/#run-tests-without-a-test-package","text":"Given a file named \"pen.json\" with: { \"type\": \"library\", \"dependencies\": {} } And a file named \"Foo.test.pen\" with: import 'Foo Add = \\() none | error { if Foo'Add(41, 1) == 42 { none } else { error(\"oh no\") } } When I successfully run pen test Then the exit status should be 0.","title":"Run tests without a Test package"},{"location":"examples/smoke/test/#keep-an-application-file-on-testing","text":"Given a file named \"pen.json\" with: { \"type\": \"application\", \"dependencies\": { \"Os\": \"pen:///os\", \"Test\": \"pen:///test\" } } And a file named \"main.pen\" with: import Os'Context { Context } main = \\(ctx context) none { none } And a file named \"main.test.pen\" with: Foo = \\() none | error { none } And I successfully run pen build When I successfully run pen test Then I successfully run ./app .","title":"Keep an application file on testing"},{"location":"examples/smoke/memory-leak/concurrency/","text":"Concurrency Background Given a file named \"pen.json\" with: { \"type\": \"application\", \"dependencies\": { \"Core\": \"pen:///core\", \"Os\": \"pen:///os\" } } Use spawn function Given a file named \"main.pen\" with: main = \\(ctx context) none { f = go(\\() none { none }) <result> } When I successfully run pen build Then I successfully run check_memory_leak.sh ./app . Examples result f() none Use spawn function with a record Given a file named \"main.pen\" with: type foo { x number y number z number } main = \\(ctx context) none { x = foo{x: 1, y: 2, z: 3} f = go(\\() none { _ = x none }) <result> } When I successfully run pen build Then I successfully run check_memory_leak.sh ./app . Examples result f() none Use spawn function with a closure Given a file named \"main.pen\" with: main = \\(ctx context) none { x = \\() none { none } f = go(\\() none { _ = x none }) <result> } When I successfully run pen build Then I successfully run check_memory_leak.sh ./app . Examples result f() none Use spawn function with a closure with a record Given a file named \"main.pen\" with: type foo { x number y number z number } main = \\(ctx context) none { x = foo{x: 1, y: 2, z: 3} y = \\() none { _ = x none } f = go(\\() none { _ = y none }) <result> } When I successfully run pen build Then I successfully run check_memory_leak.sh ./app . Examples result f() none Use race function Given a file named \"main.pen\" with: import Os'Process main = \\(ctx context) none { xs = race([[none] [none none]]) if [x, ...xs] = xs { <result> } else { Process'Exit(ctx.Os, 1) } } When I successfully run pen build Then I successfully run check_memory_leak.sh ./app . Examples result x() none Use race function with a record Given a file named \"main.pen\" with: import Os'Process type foo { x number y number } main = \\(ctx context) none { xs = race([[foo] [foo foo{x: 0, y: 0}]]) if [x, ...xs] = xs { _ = <result> none } else { Process'Exit(ctx.Os, 1) } } When I successfully run pen build Then I successfully run check_memory_leak.sh ./app . Examples result x() none","title":"Concurrency"},{"location":"examples/smoke/memory-leak/concurrency/#concurrency","text":"","title":"Concurrency"},{"location":"examples/smoke/memory-leak/concurrency/#background","text":"Given a file named \"pen.json\" with: { \"type\": \"application\", \"dependencies\": { \"Core\": \"pen:///core\", \"Os\": \"pen:///os\" } }","title":"Background"},{"location":"examples/smoke/memory-leak/concurrency/#use-spawn-function","text":"Given a file named \"main.pen\" with: main = \\(ctx context) none { f = go(\\() none { none }) <result> } When I successfully run pen build Then I successfully run check_memory_leak.sh ./app .","title":"Use spawn function"},{"location":"examples/smoke/memory-leak/concurrency/#examples","text":"result f() none","title":"Examples"},{"location":"examples/smoke/memory-leak/concurrency/#use-spawn-function-with-a-record","text":"Given a file named \"main.pen\" with: type foo { x number y number z number } main = \\(ctx context) none { x = foo{x: 1, y: 2, z: 3} f = go(\\() none { _ = x none }) <result> } When I successfully run pen build Then I successfully run check_memory_leak.sh ./app .","title":"Use spawn function with a record"},{"location":"examples/smoke/memory-leak/concurrency/#examples_1","text":"result f() none","title":"Examples"},{"location":"examples/smoke/memory-leak/concurrency/#use-spawn-function-with-a-closure","text":"Given a file named \"main.pen\" with: main = \\(ctx context) none { x = \\() none { none } f = go(\\() none { _ = x none }) <result> } When I successfully run pen build Then I successfully run check_memory_leak.sh ./app .","title":"Use spawn function with a closure"},{"location":"examples/smoke/memory-leak/concurrency/#examples_2","text":"result f() none","title":"Examples"},{"location":"examples/smoke/memory-leak/concurrency/#use-spawn-function-with-a-closure-with-a-record","text":"Given a file named \"main.pen\" with: type foo { x number y number z number } main = \\(ctx context) none { x = foo{x: 1, y: 2, z: 3} y = \\() none { _ = x none } f = go(\\() none { _ = y none }) <result> } When I successfully run pen build Then I successfully run check_memory_leak.sh ./app .","title":"Use spawn function with a closure with a record"},{"location":"examples/smoke/memory-leak/concurrency/#examples_3","text":"result f() none","title":"Examples"},{"location":"examples/smoke/memory-leak/concurrency/#use-race-function","text":"Given a file named \"main.pen\" with: import Os'Process main = \\(ctx context) none { xs = race([[none] [none none]]) if [x, ...xs] = xs { <result> } else { Process'Exit(ctx.Os, 1) } } When I successfully run pen build Then I successfully run check_memory_leak.sh ./app .","title":"Use race function"},{"location":"examples/smoke/memory-leak/concurrency/#examples_4","text":"result x() none","title":"Examples"},{"location":"examples/smoke/memory-leak/concurrency/#use-race-function-with-a-record","text":"Given a file named \"main.pen\" with: import Os'Process type foo { x number y number } main = \\(ctx context) none { xs = race([[foo] [foo foo{x: 0, y: 0}]]) if [x, ...xs] = xs { _ = <result> none } else { Process'Exit(ctx.Os, 1) } } When I successfully run pen build Then I successfully run check_memory_leak.sh ./app .","title":"Use race function with a record"},{"location":"examples/smoke/memory-leak/concurrency/#examples_5","text":"result x() none","title":"Examples"},{"location":"examples/smoke/memory-leak/language/","text":"Language Background Given a file named \"pen.json\" with: { \"type\": \"application\", \"dependencies\": { \"Core\": \"pen:///core\", \"Os\": \"pen:///os-sync\" } } Run hello world Given a file named \"main.pen\" with: import Os'Context { Context } import Os'File main = \\(ctx context) none { _ = File'Write(ctx.Os, File'StdOut(), \"Hello, world!\\n\") none } When I successfully run pen build Then I successfully run check_memory_leak.sh ./app . Create a record Given a file named \"main.pen\" with: import Os'Context { Context } type foo { x number } main = \\(ctx context) none { _ = foo{x: 42} none } When I successfully run pen build Then I successfully run check_memory_leak.sh ./app . Deconstruct a record Given a file named \"main.pen\" with: import Os'Context { Context } type foo { x number } main = \\(ctx context) none { _ = foo{x: 42}.x none } When I successfully run pen build Then I successfully run check_memory_leak.sh ./app . Put a string into a value of any type Given a file named \"main.pen\" with: import Os'Context { Context } f = \\(x any) any { x } main = \\(ctx context) none { f(\"\") none } When I successfully run pen build Then I successfully run check_memory_leak.sh ./app . Shadow a variable in a block Given a file named \"main.pen\" with: import Os'Context { Context } type foo { x number } main = \\(ctx context) none { x = foo{x: 42} x = x.x none } When I successfully run pen build Then I successfully run check_memory_leak.sh ./app . Define a function in a let expression with a free variable Given a file named \"main.pen\" with: import Os'Context { Context } type foo { x number } main = \\(ctx context) none { x = foo{x: 42} _ = \\() number { x.x } none } When I successfully run pen build Then I successfully run check_memory_leak.sh ./app . Convert a number to a string Given a file named \"main.pen\" with: import Core'Number import Os'Context { Context } main = \\(ctx context) none { Number'String(42) none } When I successfully run pen build Then I successfully run check_memory_leak.sh ./app . Join strings Given a file named \"main.pen\" with: import Core'String import Os'Context { Context } main = \\(ctx context) none { String'Join([string \"hello\", \"world\"], \" \") none } When I successfully run pen build Then I successfully run check_memory_leak.sh ./app . Drop an unforced list Given a file named \"main.pen\" with: import Os'Context { Context } type foo { x number } main = \\(ctx context) none { x = foo{x: 42} _ = [foo x] none } When I successfully run pen build Then I successfully run check_memory_leak.sh ./app . Drop a forced list Given a file named \"main.pen\" with: import Os'Context { Context } type foo { x number } main = \\(ctx context) none { x = foo{x: 42} if [x, ...xs] = [foo x] { x() } else { none } none } When I successfully run pen build Then I successfully run check_memory_leak.sh ./app . Drop an unforced list with no environment Given a file named \"main.pen\" with: import Os'Context { Context } type foo { x number } main = \\(ctx context) none { [foo foo{x: 42}] none } When I successfully run pen build Then I successfully run check_memory_leak.sh ./app . Drop a forced list with no environment Given a file named \"main.pen\" with: import Os'Context { Context } type foo { x number } main = \\(ctx context) none { if [x, ...xs] = [foo foo{x: 42}] { x() } else { none } none } When I successfully run pen build Then I successfully run check_memory_leak.sh ./app . Force an element twice Given a file named \"main.pen\" with: import Os'Context { Context } main = \\(ctx context) none { xs = [none none] if [x, ..._] = xs { x() x() } else { none } none } When I successfully run pen build Then I successfully run check_memory_leak.sh ./app . Use spawn function Given a file named \"main.pen\" with: main = \\(ctx context) none { f = go(\\() none { none }) f() } When I successfully run pen build Then I successfully run check_memory_leak.sh ./app . Use spawn function with a record Given a file named \"main.pen\" with: type foo { x number y number z number } main = \\(ctx context) none { x = foo{x: 1, y: 2, z: 3} f = go(\\() none { _ = x none }) f() } When I successfully run pen build Then I successfully run check_memory_leak.sh ./app . Use spawn function with a closure Given a file named \"main.pen\" with: main = \\(ctx context) none { x = \\() none { none } f = go(\\() none { _ = x none }) f() } When I successfully run pen build Then I successfully run check_memory_leak.sh ./app . Use spawn function with a closure with a record Given a file named \"main.pen\" with: type foo { x number y number z number } main = \\(ctx context) none { x = foo{x: 1, y: 2, z: 3} y = \\() none { _ = x none } f = go(\\() none { _ = y none }) f() } When I successfully run pen build Then I successfully run check_memory_leak.sh ./app . Concatenate strings Given a file named \"main.pen\" with: main = \\(ctx context) none { x = \"foo\" y = x + x z = y + y none } When I successfully run pen build Then I successfully run check_memory_leak.sh ./app .","title":"Language"},{"location":"examples/smoke/memory-leak/language/#language","text":"","title":"Language"},{"location":"examples/smoke/memory-leak/language/#background","text":"Given a file named \"pen.json\" with: { \"type\": \"application\", \"dependencies\": { \"Core\": \"pen:///core\", \"Os\": \"pen:///os-sync\" } }","title":"Background"},{"location":"examples/smoke/memory-leak/language/#run-hello-world","text":"Given a file named \"main.pen\" with: import Os'Context { Context } import Os'File main = \\(ctx context) none { _ = File'Write(ctx.Os, File'StdOut(), \"Hello, world!\\n\") none } When I successfully run pen build Then I successfully run check_memory_leak.sh ./app .","title":"Run hello world"},{"location":"examples/smoke/memory-leak/language/#create-a-record","text":"Given a file named \"main.pen\" with: import Os'Context { Context } type foo { x number } main = \\(ctx context) none { _ = foo{x: 42} none } When I successfully run pen build Then I successfully run check_memory_leak.sh ./app .","title":"Create a record"},{"location":"examples/smoke/memory-leak/language/#deconstruct-a-record","text":"Given a file named \"main.pen\" with: import Os'Context { Context } type foo { x number } main = \\(ctx context) none { _ = foo{x: 42}.x none } When I successfully run pen build Then I successfully run check_memory_leak.sh ./app .","title":"Deconstruct a record"},{"location":"examples/smoke/memory-leak/language/#put-a-string-into-a-value-of-any-type","text":"Given a file named \"main.pen\" with: import Os'Context { Context } f = \\(x any) any { x } main = \\(ctx context) none { f(\"\") none } When I successfully run pen build Then I successfully run check_memory_leak.sh ./app .","title":"Put a string into a value of any type"},{"location":"examples/smoke/memory-leak/language/#shadow-a-variable-in-a-block","text":"Given a file named \"main.pen\" with: import Os'Context { Context } type foo { x number } main = \\(ctx context) none { x = foo{x: 42} x = x.x none } When I successfully run pen build Then I successfully run check_memory_leak.sh ./app .","title":"Shadow a variable in a block"},{"location":"examples/smoke/memory-leak/language/#define-a-function-in-a-let-expression-with-a-free-variable","text":"Given a file named \"main.pen\" with: import Os'Context { Context } type foo { x number } main = \\(ctx context) none { x = foo{x: 42} _ = \\() number { x.x } none } When I successfully run pen build Then I successfully run check_memory_leak.sh ./app .","title":"Define a function in a let expression with a free variable"},{"location":"examples/smoke/memory-leak/language/#convert-a-number-to-a-string","text":"Given a file named \"main.pen\" with: import Core'Number import Os'Context { Context } main = \\(ctx context) none { Number'String(42) none } When I successfully run pen build Then I successfully run check_memory_leak.sh ./app .","title":"Convert a number to a string"},{"location":"examples/smoke/memory-leak/language/#join-strings","text":"Given a file named \"main.pen\" with: import Core'String import Os'Context { Context } main = \\(ctx context) none { String'Join([string \"hello\", \"world\"], \" \") none } When I successfully run pen build Then I successfully run check_memory_leak.sh ./app .","title":"Join strings"},{"location":"examples/smoke/memory-leak/language/#drop-an-unforced-list","text":"Given a file named \"main.pen\" with: import Os'Context { Context } type foo { x number } main = \\(ctx context) none { x = foo{x: 42} _ = [foo x] none } When I successfully run pen build Then I successfully run check_memory_leak.sh ./app .","title":"Drop an unforced list"},{"location":"examples/smoke/memory-leak/language/#drop-a-forced-list","text":"Given a file named \"main.pen\" with: import Os'Context { Context } type foo { x number } main = \\(ctx context) none { x = foo{x: 42} if [x, ...xs] = [foo x] { x() } else { none } none } When I successfully run pen build Then I successfully run check_memory_leak.sh ./app .","title":"Drop a forced list"},{"location":"examples/smoke/memory-leak/language/#drop-an-unforced-list-with-no-environment","text":"Given a file named \"main.pen\" with: import Os'Context { Context } type foo { x number } main = \\(ctx context) none { [foo foo{x: 42}] none } When I successfully run pen build Then I successfully run check_memory_leak.sh ./app .","title":"Drop an unforced list with no environment"},{"location":"examples/smoke/memory-leak/language/#drop-a-forced-list-with-no-environment","text":"Given a file named \"main.pen\" with: import Os'Context { Context } type foo { x number } main = \\(ctx context) none { if [x, ...xs] = [foo foo{x: 42}] { x() } else { none } none } When I successfully run pen build Then I successfully run check_memory_leak.sh ./app .","title":"Drop a forced list with no environment"},{"location":"examples/smoke/memory-leak/language/#force-an-element-twice","text":"Given a file named \"main.pen\" with: import Os'Context { Context } main = \\(ctx context) none { xs = [none none] if [x, ..._] = xs { x() x() } else { none } none } When I successfully run pen build Then I successfully run check_memory_leak.sh ./app .","title":"Force an element twice"},{"location":"examples/smoke/memory-leak/language/#use-spawn-function","text":"Given a file named \"main.pen\" with: main = \\(ctx context) none { f = go(\\() none { none }) f() } When I successfully run pen build Then I successfully run check_memory_leak.sh ./app .","title":"Use spawn function"},{"location":"examples/smoke/memory-leak/language/#use-spawn-function-with-a-record","text":"Given a file named \"main.pen\" with: type foo { x number y number z number } main = \\(ctx context) none { x = foo{x: 1, y: 2, z: 3} f = go(\\() none { _ = x none }) f() } When I successfully run pen build Then I successfully run check_memory_leak.sh ./app .","title":"Use spawn function with a record"},{"location":"examples/smoke/memory-leak/language/#use-spawn-function-with-a-closure","text":"Given a file named \"main.pen\" with: main = \\(ctx context) none { x = \\() none { none } f = go(\\() none { _ = x none }) f() } When I successfully run pen build Then I successfully run check_memory_leak.sh ./app .","title":"Use spawn function with a closure"},{"location":"examples/smoke/memory-leak/language/#use-spawn-function-with-a-closure-with-a-record","text":"Given a file named \"main.pen\" with: type foo { x number y number z number } main = \\(ctx context) none { x = foo{x: 1, y: 2, z: 3} y = \\() none { _ = x none } f = go(\\() none { _ = y none }) f() } When I successfully run pen build Then I successfully run check_memory_leak.sh ./app .","title":"Use spawn function with a closure with a record"},{"location":"examples/smoke/memory-leak/language/#concatenate-strings","text":"Given a file named \"main.pen\" with: main = \\(ctx context) none { x = \"foo\" y = x + x z = y + y none } When I successfully run pen build Then I successfully run check_memory_leak.sh ./app .","title":"Concatenate strings"},{"location":"examples/smoke/types/list/","text":"List Background Given a file named \"pen.json\" with: { \"type\": \"application\", \"dependencies\": { \"Os\": \"pen:///os\" } } Force multiple elements of a list Given a file named \"main.pen\" with: import Os'Process main = \\(ctx context) none { if [x, ...xs] = [none ...[none none]] { x() none } else { Process'Exit(ctx.Os, 1) } } When I successfully run pen build Then I successfully run check_memory_leak.sh ./app . Force an element in a list of any type Given a file named \"main.pen\" with: import Os'Process main = \\(ctx context) none { if [x, ..._] = [any \"foo\"] { x() none } else { Process'Exit(ctx.Os, 1) } } When I successfully run pen build Then I successfully run check_memory_leak.sh ./app . Compile nested list comprehension Given a file named \"main.pen\" with: import Os'Context { Context } import Os'Process f = \\(xss [[boolean]]) [[number]] { [[number] [number if x() { 1 } else { 0 } for x in xs()] for xs in xss ] } main = \\(ctx context) none { if [x, ..._] = f([[boolean] [boolean true, false]]) { x() none } else { Process'Exit(ctx.Os, 1) } } When I successfully run pen build Then I successfully run check_memory_leak.sh ./app . Compile list comprehension with wrong typing Given a file named \"main.pen\" with: main = \\(ctx context) none { _ = [none x() for x in [none 1]] none } When I run pen build Then the stderr should contain \"types not matched\". Evaluate list comprehension lazily Given a file named \"main.pen\" with: import Os'Context { Context } import Os'Process xs = \\(ctx Context) [none] { Process'Exit(ctx, 1) [none] } main = \\(ctx context) none { _ = [none x() for x in xs(ctx.Os)] none } When I successfully run pen build Then I successfully run ./app .","title":"List"},{"location":"examples/smoke/types/list/#list","text":"","title":"List"},{"location":"examples/smoke/types/list/#background","text":"Given a file named \"pen.json\" with: { \"type\": \"application\", \"dependencies\": { \"Os\": \"pen:///os\" } }","title":"Background"},{"location":"examples/smoke/types/list/#force-multiple-elements-of-a-list","text":"Given a file named \"main.pen\" with: import Os'Process main = \\(ctx context) none { if [x, ...xs] = [none ...[none none]] { x() none } else { Process'Exit(ctx.Os, 1) } } When I successfully run pen build Then I successfully run check_memory_leak.sh ./app .","title":"Force multiple elements of a list"},{"location":"examples/smoke/types/list/#force-an-element-in-a-list-of-any-type","text":"Given a file named \"main.pen\" with: import Os'Process main = \\(ctx context) none { if [x, ..._] = [any \"foo\"] { x() none } else { Process'Exit(ctx.Os, 1) } } When I successfully run pen build Then I successfully run check_memory_leak.sh ./app .","title":"Force an element in a list of any type"},{"location":"examples/smoke/types/list/#compile-nested-list-comprehension","text":"Given a file named \"main.pen\" with: import Os'Context { Context } import Os'Process f = \\(xss [[boolean]]) [[number]] { [[number] [number if x() { 1 } else { 0 } for x in xs()] for xs in xss ] } main = \\(ctx context) none { if [x, ..._] = f([[boolean] [boolean true, false]]) { x() none } else { Process'Exit(ctx.Os, 1) } } When I successfully run pen build Then I successfully run check_memory_leak.sh ./app .","title":"Compile nested list comprehension"},{"location":"examples/smoke/types/list/#compile-list-comprehension-with-wrong-typing","text":"Given a file named \"main.pen\" with: main = \\(ctx context) none { _ = [none x() for x in [none 1]] none } When I run pen build Then the stderr should contain \"types not matched\".","title":"Compile list comprehension with wrong typing"},{"location":"examples/smoke/types/list/#evaluate-list-comprehension-lazily","text":"Given a file named \"main.pen\" with: import Os'Context { Context } import Os'Process xs = \\(ctx Context) [none] { Process'Exit(ctx, 1) [none] } main = \\(ctx context) none { _ = [none x() for x in xs(ctx.Os)] none } When I successfully run pen build Then I successfully run ./app .","title":"Evaluate list comprehension lazily"},{"location":"examples/smoke/types/string/","text":"String Background Given a file named \"pen.json\" with: { \"type\": \"application\", \"dependencies\": { \"Os\": \"pen:///os\" } } Concatenate zero-length strings Given a file named \"main.pen\" with: import Os'Process main = \\(ctx context) none { debug(\"\" + \"foo\" + \"\") } When I successfully run pen build Then I successfully run check_memory_leak.sh ./app And I successfully run ./app And the stderr from \"./app\" should contain exactly \"\\\"foo\\\"\".","title":"String"},{"location":"examples/smoke/types/string/#string","text":"","title":"String"},{"location":"examples/smoke/types/string/#background","text":"Given a file named \"pen.json\" with: { \"type\": \"application\", \"dependencies\": { \"Os\": \"pen:///os\" } }","title":"Background"},{"location":"examples/smoke/types/string/#concatenate-zero-length-strings","text":"Given a file named \"main.pen\" with: import Os'Process main = \\(ctx context) none { debug(\"\" + \"foo\" + \"\") } When I successfully run pen build Then I successfully run check_memory_leak.sh ./app And I successfully run ./app And the stderr from \"./app\" should contain exactly \"\\\"foo\\\"\".","title":"Concatenate zero-length strings"},{"location":"examples/standard-packages/core/","text":"Core Background Given a file named \"pen.json\" with: { \"type\": \"library\", \"dependencies\": { \"Core\": \"pen:///core\" } } Convert a number to a string Given a file named \"Foo.pen\" with: import Core'Number f = \\() string { Number'String(42) } When I run pen build Then the exit status should be 0. Sum numbers Given a file named \"Foo.pen\" with: import Core'Number f = \\() number { Number'Sum([number 1, 2, 3]) } When I run pen build Then the exit status should be 0. Join strings Given a file named \"Foo.pen\" with: import Core'String f = \\() string { String'Join([string \"hello\", \"world\"], \" \") } When I run pen build Then the exit status should be 0. Slice a string as bytes Given a file named \"Foo.pen\" with: import Core'String'Byte f = \\() string { Byte'Slice(\"foo\", 1, 2) } When I run pen build Then the exit status should be 0.","title":"Core"},{"location":"examples/standard-packages/core/#core","text":"","title":"Core"},{"location":"examples/standard-packages/core/#background","text":"Given a file named \"pen.json\" with: { \"type\": \"library\", \"dependencies\": { \"Core\": \"pen:///core\" } }","title":"Background"},{"location":"examples/standard-packages/core/#convert-a-number-to-a-string","text":"Given a file named \"Foo.pen\" with: import Core'Number f = \\() string { Number'String(42) } When I run pen build Then the exit status should be 0.","title":"Convert a number to a string"},{"location":"examples/standard-packages/core/#sum-numbers","text":"Given a file named \"Foo.pen\" with: import Core'Number f = \\() number { Number'Sum([number 1, 2, 3]) } When I run pen build Then the exit status should be 0.","title":"Sum numbers"},{"location":"examples/standard-packages/core/#join-strings","text":"Given a file named \"Foo.pen\" with: import Core'String f = \\() string { String'Join([string \"hello\", \"world\"], \" \") } When I run pen build Then the exit status should be 0.","title":"Join strings"},{"location":"examples/standard-packages/core/#slice-a-string-as-bytes","text":"Given a file named \"Foo.pen\" with: import Core'String'Byte f = \\() string { Byte'Slice(\"foo\", 1, 2) } When I run pen build Then the exit status should be 0.","title":"Slice a string as bytes"},{"location":"examples/standard-packages/os-sync/","text":"OS (synchronous version) Background Given a file named \"pen.json\" with: { \"type\": \"application\", \"dependencies\": { \"Os\": \"pen:///os-sync\", \"Core\": \"pen:///core\" } } Build an application Given a file named \"main.pen\" with: import Os'Context { Context } import Os'File import Os'Process main = \\(ctx context) none { if _ = run(ctx.Os) as none { none } else { Process'Exit(ctx.Os, 1) } } run = \\(ctx Context) none | error { File'Write(ctx, File'StdOut(), \"Hello, world!\")? none } When I successfully run pen build Then I successfully run ./app And the stdout from \"./app\" should contain exactly \"Hello, world!\". Get arguments Given a file named \"main.pen\" with: import Core'String import Os'Context { Context } import Os'Environment import Os'File import Os'Process main = \\(ctx context) none { if _ = run(ctx.Os) as none { none } else { Process'Exit(ctx.Os, 1) } } run = \\(ctx Context) none | error { File'Write(ctx, File'StdOut(), String'Join(Environment'Arguments(ctx), \" \"))? none } When I successfully run pen build Then I successfully run ./app foo bar And stdout from \"./app foo bar\" should contain exactly \"foo bar\". Get an environment variable Given a file named \"main.pen\" with: import Core'String import Os'Context { Context } import Os'File import Os'Environment import Os'Process main = \\(ctx context) none { if _ = run(ctx.Os) as none { none } else { Process'Exit(ctx.Os, 1) } } run = \\(ctx Context) none | error { File'Write(ctx, File'StdOut(), Environment'Variable(ctx, \"FOO\")?)? none } And I append \"foo\" to the environment variable \"FOO\" When I successfully run pen build Then I successfully run ./app And stdout from \"./app\" should contain exactly \"foo\". Open a file Given a file named \"main.pen\" with: import Os'Context { Context } import Os'File { File } import Os'Process main = \\(ctx context) none { if _ = run(ctx.Os) as none { none } else { Process'Exit(ctx.Os, 1) } } run = \\(ctx Context) none | error { File'Open(ctx, \"./foo.txt\")? none } And a file named \"foo.txt\" with \"\" When I successfully run pen build Then I successfully run ./app . Read a file Given a file named \"main.pen\" with: import Os'Context { Context } import Os'File import Os'File'OpenOptions import Os'Process main = \\(ctx context) none { if _ = run(ctx.Os) as none { none } else { Process'Exit(ctx.Os, 1) } } run = \\(ctx Context) none | error { f = File'Open(ctx, \"foo.txt\")? d = File'Read(ctx, f)? File'Write(ctx, File'StdOut(), d)? none } And a file named \"foo.txt\" with \"foo\" When I successfully run pen build Then I successfully run ./app And the stdout from \"./app\" should contain exactly \"foo\". Read a file until a limit Given a file named \"main.pen\" with: import Os'Context { Context } import Os'File import Os'Process main = \\(ctx context) none { if _ = run(ctx.Os) as none { none } else { Process'Exit(ctx.Os, 1) } } run = \\(ctx Context) none | error { f = File'Open(ctx, \"foo.txt\")? d = File'ReadLimit(ctx, f, 5)? File'Write(ctx, File'StdOut(), d)? none } And a file named \"foo.txt\" with \"Hello, world!\" When I successfully run pen build Then I successfully run ./app And the stdout from \"./app\" should contain exactly \"Hello\". Write a file Given a file named \"main.pen\" with: import Os'Context { Context } import Os'File import Os'File'OpenOptions { OpenOptions } import Os'Process main = \\(ctx context) none { if _ = run(ctx.Os) as none { none } else { Process'Exit(ctx.Os, 1) } } run = \\(ctx Context) none | error { f = File'OpenWithOptions( ctx, \"./foo.txt\", OpenOptions{...OpenOptions'Default(), Write: true}, )? File'Write(ctx, f, \"foo\")? none } And a file named \"foo.txt\" with \"\" When I successfully run pen build Then I successfully run ./app And the file \"foo.txt\" should contain \"foo\". Copy a file Given a file named \"main.pen\" with: import Os'Context { Context } import Os'File import Os'Process main = \\(ctx context) none { if _ = File'Copy(ctx.Os, \"foo.txt\", \"bar.txt\") as none { none } else { Process'Exit(ctx.Os, 1) } } And a file named \"foo.txt\" with \"foo\" When I successfully run pen build Then I successfully run ./app And the file \"foo.txt\" should contain \"foo\" And the file \"bar.txt\" should contain \"foo\". Move a file Given a file named \"main.pen\" with: import Os'Context { Context } import Os'File import Os'Process main = \\(ctx context) none { if _ = File'Move(ctx.Os, \"foo.txt\", \"bar.txt\") as none { none } else { Process'Exit(ctx.Os, 1) } } And a file named \"foo.txt\" with \"foo\" When I successfully run pen build Then I successfully run ./app And the file \"foo.txt\" does not exist And the file \"bar.txt\" should contain \"foo\". Remove a file Given a file named \"main.pen\" with: import Os'Context { Context } import Os'File import Os'Process main = \\(ctx context) none { if _ = File'Remove(ctx.Os, \"foo.txt\") as none { none } else { Process'Exit(ctx.Os, 1) } } And a file named \"foo.txt\" with \"\" When I successfully run pen build Then I successfully run ./app And the file \"foo.txt\" does not exist. Read a directory Given a file named \"main.pen\" with: import Core'String import Os'Context { Context } import Os'File import Os'Directory import Os'Process main = \\(ctx context) none { if _ = run(ctx.Os) as none { none } else { Process'Exit(ctx.Os, 1) } } run = \\(ctx Context) none | error { File'Write( ctx, File'StdOut(), String'Join(Directory'Read(ctx, \".\")?, \"\\n\"), )? none } When I successfully run pen build Then I successfully run ./app And the stdout from \"./app\" should contain \"main.pen\" And the stdout from \"./app\" should contain \"pen.json\". Create a directory Given a file named \"main.pen\" with: import Os'Context { Context } import Os'Directory import Os'Process main = \\(ctx context) none { if _ = Directory'Create(ctx.Os, \"foo\") as none { none } else { Process'Exit(ctx.Os, 1) } } When I successfully run pen build Then I successfully run ./app And a directory named \"foo\" should exist. Remove a directory Given a file named \"main.pen\" with: import Os'Context { Context } import Os'Directory import Os'Process main = \\(ctx context) none { if _ = Directory'Remove(ctx.Os, \"foo\") as none { none } else { Process'Exit(ctx.Os, 1) } } And a directory named \"foo\" When I successfully run pen build Then I successfully run ./app And a directory named \"foo\" should not exist. Get file metadata Given a file named \"main.pen\" with: import Os'Context { Context } import Os'File import Os'File'Metadata { Metadata } import Os'Process main = \\(ctx context) none { m = File'Metadata(ctx.Os, \"foo\") c = if m = m as Metadata { if m.Size == 3 { 0 } else { 1 } } else { 1 } Process'Exit(ctx.Os, c) } And a file named \"foo\" with: foo When I successfully run pen build Then I successfully run ./app . Get system time Given a file named \"main.pen\" with: import Core'Number import Os'Context { Context } import Os'File import Os'Process import Os'Time main = \\(ctx context) none { if m = run(ctx.Os) as none { none } else { Process'Exit(ctx.Os, 1) } } run = \\(ctx Context) none | error { File'Write(ctx, File'StdOut(), Number'String(Time'Now(ctx)))? none } When I successfully run pen build Then I successfully run ./app . Sleep Given a file named \"main.pen\" with: import Os'Context { Context } import Os'Time main = \\(ctx context) none { Time'Sleep(ctx.Os, 1) } When I successfully run pen build Then I successfully run ./app . Exit a process Given a file named \"main.pen\" with: import Os'Context { Context } import Os'Process main = \\(ctx context) none { Process'Exit(ctx.Os, 42) } When I successfully run pen build Then I run ./app And the exit status should be 42.","title":"OS (synchronous version)"},{"location":"examples/standard-packages/os-sync/#os-synchronous-version","text":"","title":"OS (synchronous version)"},{"location":"examples/standard-packages/os-sync/#background","text":"Given a file named \"pen.json\" with: { \"type\": \"application\", \"dependencies\": { \"Os\": \"pen:///os-sync\", \"Core\": \"pen:///core\" } }","title":"Background"},{"location":"examples/standard-packages/os-sync/#build-an-application","text":"Given a file named \"main.pen\" with: import Os'Context { Context } import Os'File import Os'Process main = \\(ctx context) none { if _ = run(ctx.Os) as none { none } else { Process'Exit(ctx.Os, 1) } } run = \\(ctx Context) none | error { File'Write(ctx, File'StdOut(), \"Hello, world!\")? none } When I successfully run pen build Then I successfully run ./app And the stdout from \"./app\" should contain exactly \"Hello, world!\".","title":"Build an application"},{"location":"examples/standard-packages/os-sync/#get-arguments","text":"Given a file named \"main.pen\" with: import Core'String import Os'Context { Context } import Os'Environment import Os'File import Os'Process main = \\(ctx context) none { if _ = run(ctx.Os) as none { none } else { Process'Exit(ctx.Os, 1) } } run = \\(ctx Context) none | error { File'Write(ctx, File'StdOut(), String'Join(Environment'Arguments(ctx), \" \"))? none } When I successfully run pen build Then I successfully run ./app foo bar And stdout from \"./app foo bar\" should contain exactly \"foo bar\".","title":"Get arguments"},{"location":"examples/standard-packages/os-sync/#get-an-environment-variable","text":"Given a file named \"main.pen\" with: import Core'String import Os'Context { Context } import Os'File import Os'Environment import Os'Process main = \\(ctx context) none { if _ = run(ctx.Os) as none { none } else { Process'Exit(ctx.Os, 1) } } run = \\(ctx Context) none | error { File'Write(ctx, File'StdOut(), Environment'Variable(ctx, \"FOO\")?)? none } And I append \"foo\" to the environment variable \"FOO\" When I successfully run pen build Then I successfully run ./app And stdout from \"./app\" should contain exactly \"foo\".","title":"Get an environment variable"},{"location":"examples/standard-packages/os-sync/#open-a-file","text":"Given a file named \"main.pen\" with: import Os'Context { Context } import Os'File { File } import Os'Process main = \\(ctx context) none { if _ = run(ctx.Os) as none { none } else { Process'Exit(ctx.Os, 1) } } run = \\(ctx Context) none | error { File'Open(ctx, \"./foo.txt\")? none } And a file named \"foo.txt\" with \"\" When I successfully run pen build Then I successfully run ./app .","title":"Open a file"},{"location":"examples/standard-packages/os-sync/#read-a-file","text":"Given a file named \"main.pen\" with: import Os'Context { Context } import Os'File import Os'File'OpenOptions import Os'Process main = \\(ctx context) none { if _ = run(ctx.Os) as none { none } else { Process'Exit(ctx.Os, 1) } } run = \\(ctx Context) none | error { f = File'Open(ctx, \"foo.txt\")? d = File'Read(ctx, f)? File'Write(ctx, File'StdOut(), d)? none } And a file named \"foo.txt\" with \"foo\" When I successfully run pen build Then I successfully run ./app And the stdout from \"./app\" should contain exactly \"foo\".","title":"Read a file"},{"location":"examples/standard-packages/os-sync/#read-a-file-until-a-limit","text":"Given a file named \"main.pen\" with: import Os'Context { Context } import Os'File import Os'Process main = \\(ctx context) none { if _ = run(ctx.Os) as none { none } else { Process'Exit(ctx.Os, 1) } } run = \\(ctx Context) none | error { f = File'Open(ctx, \"foo.txt\")? d = File'ReadLimit(ctx, f, 5)? File'Write(ctx, File'StdOut(), d)? none } And a file named \"foo.txt\" with \"Hello, world!\" When I successfully run pen build Then I successfully run ./app And the stdout from \"./app\" should contain exactly \"Hello\".","title":"Read a file until a limit"},{"location":"examples/standard-packages/os-sync/#write-a-file","text":"Given a file named \"main.pen\" with: import Os'Context { Context } import Os'File import Os'File'OpenOptions { OpenOptions } import Os'Process main = \\(ctx context) none { if _ = run(ctx.Os) as none { none } else { Process'Exit(ctx.Os, 1) } } run = \\(ctx Context) none | error { f = File'OpenWithOptions( ctx, \"./foo.txt\", OpenOptions{...OpenOptions'Default(), Write: true}, )? File'Write(ctx, f, \"foo\")? none } And a file named \"foo.txt\" with \"\" When I successfully run pen build Then I successfully run ./app And the file \"foo.txt\" should contain \"foo\".","title":"Write a file"},{"location":"examples/standard-packages/os-sync/#copy-a-file","text":"Given a file named \"main.pen\" with: import Os'Context { Context } import Os'File import Os'Process main = \\(ctx context) none { if _ = File'Copy(ctx.Os, \"foo.txt\", \"bar.txt\") as none { none } else { Process'Exit(ctx.Os, 1) } } And a file named \"foo.txt\" with \"foo\" When I successfully run pen build Then I successfully run ./app And the file \"foo.txt\" should contain \"foo\" And the file \"bar.txt\" should contain \"foo\".","title":"Copy a file"},{"location":"examples/standard-packages/os-sync/#move-a-file","text":"Given a file named \"main.pen\" with: import Os'Context { Context } import Os'File import Os'Process main = \\(ctx context) none { if _ = File'Move(ctx.Os, \"foo.txt\", \"bar.txt\") as none { none } else { Process'Exit(ctx.Os, 1) } } And a file named \"foo.txt\" with \"foo\" When I successfully run pen build Then I successfully run ./app And the file \"foo.txt\" does not exist And the file \"bar.txt\" should contain \"foo\".","title":"Move a file"},{"location":"examples/standard-packages/os-sync/#remove-a-file","text":"Given a file named \"main.pen\" with: import Os'Context { Context } import Os'File import Os'Process main = \\(ctx context) none { if _ = File'Remove(ctx.Os, \"foo.txt\") as none { none } else { Process'Exit(ctx.Os, 1) } } And a file named \"foo.txt\" with \"\" When I successfully run pen build Then I successfully run ./app And the file \"foo.txt\" does not exist.","title":"Remove a file"},{"location":"examples/standard-packages/os-sync/#read-a-directory","text":"Given a file named \"main.pen\" with: import Core'String import Os'Context { Context } import Os'File import Os'Directory import Os'Process main = \\(ctx context) none { if _ = run(ctx.Os) as none { none } else { Process'Exit(ctx.Os, 1) } } run = \\(ctx Context) none | error { File'Write( ctx, File'StdOut(), String'Join(Directory'Read(ctx, \".\")?, \"\\n\"), )? none } When I successfully run pen build Then I successfully run ./app And the stdout from \"./app\" should contain \"main.pen\" And the stdout from \"./app\" should contain \"pen.json\".","title":"Read a directory"},{"location":"examples/standard-packages/os-sync/#create-a-directory","text":"Given a file named \"main.pen\" with: import Os'Context { Context } import Os'Directory import Os'Process main = \\(ctx context) none { if _ = Directory'Create(ctx.Os, \"foo\") as none { none } else { Process'Exit(ctx.Os, 1) } } When I successfully run pen build Then I successfully run ./app And a directory named \"foo\" should exist.","title":"Create a directory"},{"location":"examples/standard-packages/os-sync/#remove-a-directory","text":"Given a file named \"main.pen\" with: import Os'Context { Context } import Os'Directory import Os'Process main = \\(ctx context) none { if _ = Directory'Remove(ctx.Os, \"foo\") as none { none } else { Process'Exit(ctx.Os, 1) } } And a directory named \"foo\" When I successfully run pen build Then I successfully run ./app And a directory named \"foo\" should not exist.","title":"Remove a directory"},{"location":"examples/standard-packages/os-sync/#get-file-metadata","text":"Given a file named \"main.pen\" with: import Os'Context { Context } import Os'File import Os'File'Metadata { Metadata } import Os'Process main = \\(ctx context) none { m = File'Metadata(ctx.Os, \"foo\") c = if m = m as Metadata { if m.Size == 3 { 0 } else { 1 } } else { 1 } Process'Exit(ctx.Os, c) } And a file named \"foo\" with: foo When I successfully run pen build Then I successfully run ./app .","title":"Get file metadata"},{"location":"examples/standard-packages/os-sync/#get-system-time","text":"Given a file named \"main.pen\" with: import Core'Number import Os'Context { Context } import Os'File import Os'Process import Os'Time main = \\(ctx context) none { if m = run(ctx.Os) as none { none } else { Process'Exit(ctx.Os, 1) } } run = \\(ctx Context) none | error { File'Write(ctx, File'StdOut(), Number'String(Time'Now(ctx)))? none } When I successfully run pen build Then I successfully run ./app .","title":"Get system time"},{"location":"examples/standard-packages/os-sync/#sleep","text":"Given a file named \"main.pen\" with: import Os'Context { Context } import Os'Time main = \\(ctx context) none { Time'Sleep(ctx.Os, 1) } When I successfully run pen build Then I successfully run ./app .","title":"Sleep"},{"location":"examples/standard-packages/os-sync/#exit-a-process","text":"Given a file named \"main.pen\" with: import Os'Context { Context } import Os'Process main = \\(ctx context) none { Process'Exit(ctx.Os, 42) } When I successfully run pen build Then I run ./app And the exit status should be 42.","title":"Exit a process"},{"location":"examples/standard-packages/os/","text":"Os Background Given a file named \"pen.json\" with: { \"type\": \"application\", \"dependencies\": { \"Os\": \"pen:///os\", \"Core\": \"pen:///core\" } } Build an application Given a file named \"main.pen\" with: import Os'Context { Context } import Os'File import Os'Process main = \\(ctx context) none { if _ = run(ctx.Os) as none { none } else { Process'Exit(ctx.Os, 1) } } run = \\(ctx Context) none | error { File'Write(ctx, File'StdOut(), \"Hello, world!\")? none } When I successfully run pen build Then I successfully run ./app And the stdout from \"./app\" should contain exactly \"Hello, world!\". Get arguments Given a file named \"main.pen\" with: import Core'String import Os'Context { Context } import Os'Environment import Os'File import Os'Process main = \\(ctx context) none { if _ = run(ctx.Os) as none { none } else { Process'Exit(ctx.Os, 1) } } run = \\(ctx Context) none | error { File'Write(ctx, File'StdOut(), String'Join(Environment'Arguments(ctx), \" \"))? none } When I successfully run pen build Then I successfully run ./app foo bar And stdout from \"./app foo bar\" should contain exactly \"foo bar\". Get an environment variable Given a file named \"main.pen\" with: import Core'String import Os'Context { Context } import Os'File import Os'Environment import Os'Process main = \\(ctx context) none { if _ = run(ctx.Os) as none { none } else { Process'Exit(ctx.Os, 1) } } run = \\(ctx Context) none | error { File'Write(ctx, File'StdOut(), Environment'Variable(ctx, \"FOO\")?)? none } And I append \"foo\" to the environment variable \"FOO\" When I successfully run pen build Then I successfully run ./app And stdout from \"./app\" should contain exactly \"foo\". Open a file Given a file named \"main.pen\" with: import Os'Context { Context } import Os'File { File } import Os'Process main = \\(ctx context) none { if _ = run(ctx.Os) as none { none } else { Process'Exit(ctx.Os, 1) } } run = \\(ctx Context) none | error { File'Open(ctx, \"./foo.txt\")? none } And a file named \"foo.txt\" with \"\" When I successfully run pen build Then I successfully run ./app . Read a file Given a file named \"main.pen\" with: import Os'Context { Context } import Os'File import Os'File'OpenOptions import Os'Process main = \\(ctx context) none { if _ = run(ctx.Os) as none { none } else { Process'Exit(ctx.Os, 1) } } run = \\(ctx Context) none | error { f = File'Open(ctx, \"foo.txt\")? d = File'Read(ctx, f)? File'Write(ctx, File'StdOut(), d)? none } And a file named \"foo.txt\" with \"foo\" When I successfully run pen build Then I successfully run ./app And the stdout from \"./app\" should contain exactly \"foo\". Read a file until a limit Given a file named \"main.pen\" with: import Os'Context { Context } import Os'File import Os'Process main = \\(ctx context) none { if _ = run(ctx.Os) as none { none } else { Process'Exit(ctx.Os, 1) } } run = \\(ctx Context) none | error { f = File'Open(ctx, \"foo.txt\")? d = File'ReadLimit(ctx, f, 5)? File'Write(ctx, File'StdOut(), d)? none } And a file named \"foo.txt\" with \"Hello, world!\" When I successfully run pen build Then I successfully run ./app And the stdout from \"./app\" should contain exactly \"Hello\". Write a file Given a file named \"main.pen\" with: import Os'Context { Context } import Os'File import Os'File'OpenOptions { OpenOptions } import Os'Process main = \\(ctx context) none { if _ = run(ctx.Os) as none { none } else { Process'Exit(ctx.Os, 1) } } run = \\(ctx Context) none | error { f = File'OpenWithOptions( ctx, \"./foo.txt\", OpenOptions{...OpenOptions'Default(), Write: true}, )? File'Write(ctx, f, \"foo\")? none } And a file named \"foo.txt\" with \"\" When I successfully run pen build Then I successfully run ./app And the file \"foo.txt\" should contain \"foo\". Copy a file Given a file named \"main.pen\" with: import Os'Context { Context } import Os'File import Os'Process main = \\(ctx context) none { if _ = File'Copy(ctx.Os, \"foo.txt\", \"bar.txt\") as none { none } else { Process'Exit(ctx.Os, 1) } } And a file named \"foo.txt\" with \"foo\" When I successfully run pen build Then I successfully run ./app And the file \"foo.txt\" should contain \"foo\" And the file \"bar.txt\" should contain \"foo\". Move a file Given a file named \"main.pen\" with: import Os'Context { Context } import Os'File import Os'Process main = \\(ctx context) none { if _ = File'Move(ctx.Os, \"foo.txt\", \"bar.txt\") as none { none } else { Process'Exit(ctx.Os, 1) } } And a file named \"foo.txt\" with \"foo\" When I successfully run pen build Then I successfully run ./app And the file \"foo.txt\" does not exist And the file \"bar.txt\" should contain \"foo\". Remove a file Given a file named \"main.pen\" with: import Os'Context { Context } import Os'File import Os'Process main = \\(ctx context) none { if _ = File'Remove(ctx.Os, \"foo.txt\") as none { none } else { Process'Exit(ctx.Os, 1) } } And a file named \"foo.txt\" with \"\" When I successfully run pen build Then I successfully run ./app And the file \"foo.txt\" does not exist. Read a directory Given a file named \"main.pen\" with: import Core'String import Os'Context { Context } import Os'File import Os'Directory import Os'Process main = \\(ctx context) none { if _ = run(ctx.Os) as none { none } else { Process'Exit(ctx.Os, 1) } } run = \\(ctx Context) none | error { File'Write( ctx, File'StdOut(), String'Join(Directory'Read(ctx, \".\")?, \"\\n\"), )? none } When I successfully run pen build Then I successfully run ./app And the stdout from \"./app\" should contain \"main.pen\" And the stdout from \"./app\" should contain \"pen.json\". Create a directory Given a file named \"main.pen\" with: import Os'Context { Context } import Os'Directory import Os'Process main = \\(ctx context) none { if _ = Directory'Create(ctx.Os, \"foo\") as none { none } else { Process'Exit(ctx.Os, 1) } } When I successfully run pen build Then I successfully run ./app And a directory named \"foo\" should exist. Remove a directory Given a file named \"main.pen\" with: import Os'Context { Context } import Os'Directory import Os'Process main = \\(ctx context) none { if _ = Directory'Remove(ctx.Os, \"foo\") as none { none } else { Process'Exit(ctx.Os, 1) } } And a directory named \"foo\" When I successfully run pen build Then I successfully run ./app And a directory named \"foo\" should not exist. Get file metadata Given a file named \"main.pen\" with: import Os'Context { Context } import Os'File import Os'File'Metadata { Metadata } import Os'Process main = \\(ctx context) none { m = File'Metadata(ctx.Os, \"foo\") c = if m = m as Metadata { if m.Size == 3 { 0 } else { 1 } } else { 1 } Process'Exit(ctx.Os, c) } And a file named \"foo\" with: foo When I successfully run pen build Then I successfully run ./app . Get system time Given a file named \"main.pen\" with: import Core'Number import Os'Context { Context } import Os'File import Os'Process import Os'Time main = \\(ctx context) none { if m = run(ctx.Os) as none { none } else { Process'Exit(ctx.Os, 1) } } run = \\(ctx Context) none | error { File'Write(ctx, File'StdOut(), Number'String(Time'Now(ctx)))? none } When I successfully run pen build Then I successfully run ./app . Sleep Given a file named \"main.pen\" with: import Os'Context { Context } import Os'Time main = \\(ctx context) none { Time'Sleep(ctx.Os, 1) } When I successfully run pen build Then I successfully run ./app . Exit a process Given a file named \"main.pen\" with: import Os'Context { Context } import Os'Process main = \\(ctx context) none { Process'Exit(ctx.Os, 42) } When I successfully run pen build Then I run ./app And the exit status should be 42.","title":"Os"},{"location":"examples/standard-packages/os/#os","text":"","title":"Os"},{"location":"examples/standard-packages/os/#background","text":"Given a file named \"pen.json\" with: { \"type\": \"application\", \"dependencies\": { \"Os\": \"pen:///os\", \"Core\": \"pen:///core\" } }","title":"Background"},{"location":"examples/standard-packages/os/#build-an-application","text":"Given a file named \"main.pen\" with: import Os'Context { Context } import Os'File import Os'Process main = \\(ctx context) none { if _ = run(ctx.Os) as none { none } else { Process'Exit(ctx.Os, 1) } } run = \\(ctx Context) none | error { File'Write(ctx, File'StdOut(), \"Hello, world!\")? none } When I successfully run pen build Then I successfully run ./app And the stdout from \"./app\" should contain exactly \"Hello, world!\".","title":"Build an application"},{"location":"examples/standard-packages/os/#get-arguments","text":"Given a file named \"main.pen\" with: import Core'String import Os'Context { Context } import Os'Environment import Os'File import Os'Process main = \\(ctx context) none { if _ = run(ctx.Os) as none { none } else { Process'Exit(ctx.Os, 1) } } run = \\(ctx Context) none | error { File'Write(ctx, File'StdOut(), String'Join(Environment'Arguments(ctx), \" \"))? none } When I successfully run pen build Then I successfully run ./app foo bar And stdout from \"./app foo bar\" should contain exactly \"foo bar\".","title":"Get arguments"},{"location":"examples/standard-packages/os/#get-an-environment-variable","text":"Given a file named \"main.pen\" with: import Core'String import Os'Context { Context } import Os'File import Os'Environment import Os'Process main = \\(ctx context) none { if _ = run(ctx.Os) as none { none } else { Process'Exit(ctx.Os, 1) } } run = \\(ctx Context) none | error { File'Write(ctx, File'StdOut(), Environment'Variable(ctx, \"FOO\")?)? none } And I append \"foo\" to the environment variable \"FOO\" When I successfully run pen build Then I successfully run ./app And stdout from \"./app\" should contain exactly \"foo\".","title":"Get an environment variable"},{"location":"examples/standard-packages/os/#open-a-file","text":"Given a file named \"main.pen\" with: import Os'Context { Context } import Os'File { File } import Os'Process main = \\(ctx context) none { if _ = run(ctx.Os) as none { none } else { Process'Exit(ctx.Os, 1) } } run = \\(ctx Context) none | error { File'Open(ctx, \"./foo.txt\")? none } And a file named \"foo.txt\" with \"\" When I successfully run pen build Then I successfully run ./app .","title":"Open a file"},{"location":"examples/standard-packages/os/#read-a-file","text":"Given a file named \"main.pen\" with: import Os'Context { Context } import Os'File import Os'File'OpenOptions import Os'Process main = \\(ctx context) none { if _ = run(ctx.Os) as none { none } else { Process'Exit(ctx.Os, 1) } } run = \\(ctx Context) none | error { f = File'Open(ctx, \"foo.txt\")? d = File'Read(ctx, f)? File'Write(ctx, File'StdOut(), d)? none } And a file named \"foo.txt\" with \"foo\" When I successfully run pen build Then I successfully run ./app And the stdout from \"./app\" should contain exactly \"foo\".","title":"Read a file"},{"location":"examples/standard-packages/os/#read-a-file-until-a-limit","text":"Given a file named \"main.pen\" with: import Os'Context { Context } import Os'File import Os'Process main = \\(ctx context) none { if _ = run(ctx.Os) as none { none } else { Process'Exit(ctx.Os, 1) } } run = \\(ctx Context) none | error { f = File'Open(ctx, \"foo.txt\")? d = File'ReadLimit(ctx, f, 5)? File'Write(ctx, File'StdOut(), d)? none } And a file named \"foo.txt\" with \"Hello, world!\" When I successfully run pen build Then I successfully run ./app And the stdout from \"./app\" should contain exactly \"Hello\".","title":"Read a file until a limit"},{"location":"examples/standard-packages/os/#write-a-file","text":"Given a file named \"main.pen\" with: import Os'Context { Context } import Os'File import Os'File'OpenOptions { OpenOptions } import Os'Process main = \\(ctx context) none { if _ = run(ctx.Os) as none { none } else { Process'Exit(ctx.Os, 1) } } run = \\(ctx Context) none | error { f = File'OpenWithOptions( ctx, \"./foo.txt\", OpenOptions{...OpenOptions'Default(), Write: true}, )? File'Write(ctx, f, \"foo\")? none } And a file named \"foo.txt\" with \"\" When I successfully run pen build Then I successfully run ./app And the file \"foo.txt\" should contain \"foo\".","title":"Write a file"},{"location":"examples/standard-packages/os/#copy-a-file","text":"Given a file named \"main.pen\" with: import Os'Context { Context } import Os'File import Os'Process main = \\(ctx context) none { if _ = File'Copy(ctx.Os, \"foo.txt\", \"bar.txt\") as none { none } else { Process'Exit(ctx.Os, 1) } } And a file named \"foo.txt\" with \"foo\" When I successfully run pen build Then I successfully run ./app And the file \"foo.txt\" should contain \"foo\" And the file \"bar.txt\" should contain \"foo\".","title":"Copy a file"},{"location":"examples/standard-packages/os/#move-a-file","text":"Given a file named \"main.pen\" with: import Os'Context { Context } import Os'File import Os'Process main = \\(ctx context) none { if _ = File'Move(ctx.Os, \"foo.txt\", \"bar.txt\") as none { none } else { Process'Exit(ctx.Os, 1) } } And a file named \"foo.txt\" with \"foo\" When I successfully run pen build Then I successfully run ./app And the file \"foo.txt\" does not exist And the file \"bar.txt\" should contain \"foo\".","title":"Move a file"},{"location":"examples/standard-packages/os/#remove-a-file","text":"Given a file named \"main.pen\" with: import Os'Context { Context } import Os'File import Os'Process main = \\(ctx context) none { if _ = File'Remove(ctx.Os, \"foo.txt\") as none { none } else { Process'Exit(ctx.Os, 1) } } And a file named \"foo.txt\" with \"\" When I successfully run pen build Then I successfully run ./app And the file \"foo.txt\" does not exist.","title":"Remove a file"},{"location":"examples/standard-packages/os/#read-a-directory","text":"Given a file named \"main.pen\" with: import Core'String import Os'Context { Context } import Os'File import Os'Directory import Os'Process main = \\(ctx context) none { if _ = run(ctx.Os) as none { none } else { Process'Exit(ctx.Os, 1) } } run = \\(ctx Context) none | error { File'Write( ctx, File'StdOut(), String'Join(Directory'Read(ctx, \".\")?, \"\\n\"), )? none } When I successfully run pen build Then I successfully run ./app And the stdout from \"./app\" should contain \"main.pen\" And the stdout from \"./app\" should contain \"pen.json\".","title":"Read a directory"},{"location":"examples/standard-packages/os/#create-a-directory","text":"Given a file named \"main.pen\" with: import Os'Context { Context } import Os'Directory import Os'Process main = \\(ctx context) none { if _ = Directory'Create(ctx.Os, \"foo\") as none { none } else { Process'Exit(ctx.Os, 1) } } When I successfully run pen build Then I successfully run ./app And a directory named \"foo\" should exist.","title":"Create a directory"},{"location":"examples/standard-packages/os/#remove-a-directory","text":"Given a file named \"main.pen\" with: import Os'Context { Context } import Os'Directory import Os'Process main = \\(ctx context) none { if _ = Directory'Remove(ctx.Os, \"foo\") as none { none } else { Process'Exit(ctx.Os, 1) } } And a directory named \"foo\" When I successfully run pen build Then I successfully run ./app And a directory named \"foo\" should not exist.","title":"Remove a directory"},{"location":"examples/standard-packages/os/#get-file-metadata","text":"Given a file named \"main.pen\" with: import Os'Context { Context } import Os'File import Os'File'Metadata { Metadata } import Os'Process main = \\(ctx context) none { m = File'Metadata(ctx.Os, \"foo\") c = if m = m as Metadata { if m.Size == 3 { 0 } else { 1 } } else { 1 } Process'Exit(ctx.Os, c) } And a file named \"foo\" with: foo When I successfully run pen build Then I successfully run ./app .","title":"Get file metadata"},{"location":"examples/standard-packages/os/#get-system-time","text":"Given a file named \"main.pen\" with: import Core'Number import Os'Context { Context } import Os'File import Os'Process import Os'Time main = \\(ctx context) none { if m = run(ctx.Os) as none { none } else { Process'Exit(ctx.Os, 1) } } run = \\(ctx Context) none | error { File'Write(ctx, File'StdOut(), Number'String(Time'Now(ctx)))? none } When I successfully run pen build Then I successfully run ./app .","title":"Get system time"},{"location":"examples/standard-packages/os/#sleep","text":"Given a file named \"main.pen\" with: import Os'Context { Context } import Os'Time main = \\(ctx context) none { Time'Sleep(ctx.Os, 1) } When I successfully run pen build Then I successfully run ./app .","title":"Sleep"},{"location":"examples/standard-packages/os/#exit-a-process","text":"Given a file named \"main.pen\" with: import Os'Context { Context } import Os'Process main = \\(ctx context) none { Process'Exit(ctx.Os, 42) } When I successfully run pen build Then I run ./app And the exit status should be 42.","title":"Exit a process"},{"location":"examples/standard-packages/random/","text":"Random Background Given a file named \"pen.json\" with: { \"type\": \"application\", \"dependencies\": { \"Core\": \"pen:///core\", \"Os\": \"pen:///os\", \"Random\": \"pen:///random\" } } Generate a random number Given a file named \"main.pen\" with: import Core'Number import Os'Context { Context } import Os'File import Os'Process import Random'Random main = \\(ctx context) none { if m = run(ctx) as none { none } else { Process'Exit(ctx.Os, 1) } } run = \\(ctx context) none | error { File'Write(ctx.Os, File'StdOut(), Number'String(Random'Number(ctx.Random)))? none } When I successfully run pen build Then I successfully run ./app .","title":"Random"},{"location":"examples/standard-packages/random/#random","text":"","title":"Random"},{"location":"examples/standard-packages/random/#background","text":"Given a file named \"pen.json\" with: { \"type\": \"application\", \"dependencies\": { \"Core\": \"pen:///core\", \"Os\": \"pen:///os\", \"Random\": \"pen:///random\" } }","title":"Background"},{"location":"examples/standard-packages/random/#generate-a-random-number","text":"Given a file named \"main.pen\" with: import Core'Number import Os'Context { Context } import Os'File import Os'Process import Random'Random main = \\(ctx context) none { if m = run(ctx) as none { none } else { Process'Exit(ctx.Os, 1) } } run = \\(ctx context) none | error { File'Write(ctx.Os, File'StdOut(), Number'String(Random'Number(ctx.Random)))? none } When I successfully run pen build Then I successfully run ./app .","title":"Generate a random number"},{"location":"examples/standard-packages/test/","text":"Test Background Given a file named \"pen.json\" with: { \"type\": \"library\", \"dependencies\": { \"Test\": \"pen:///test\" } } Check if a condition is true Given a file named \"foo.test.pen\" with: import Test'Assert Foo = \\() none | error { Assert'True(true) } When I run pen test Then the exit status should be 0. Check if a value is an error Given a file named \"foo.test.pen\" with: import Test'Assert Foo = \\() none | error { Assert'Error(error(none)) } When I run pen test Then the exit status should be 0. Make a test fail Given a file named \"foo.test.pen\" with: import Test'Assert Foo = \\() none | error { Assert'Fail() } When I run pen test Then the exit status should be 1.","title":"Test"},{"location":"examples/standard-packages/test/#test","text":"","title":"Test"},{"location":"examples/standard-packages/test/#background","text":"Given a file named \"pen.json\" with: { \"type\": \"library\", \"dependencies\": { \"Test\": \"pen:///test\" } }","title":"Background"},{"location":"examples/standard-packages/test/#check-if-a-condition-is-true","text":"Given a file named \"foo.test.pen\" with: import Test'Assert Foo = \\() none | error { Assert'True(true) } When I run pen test Then the exit status should be 0.","title":"Check if a condition is true"},{"location":"examples/standard-packages/test/#check-if-a-value-is-an-error","text":"Given a file named \"foo.test.pen\" with: import Test'Assert Foo = \\() none | error { Assert'Error(error(none)) } When I run pen test Then the exit status should be 0.","title":"Check if a value is an error"},{"location":"examples/standard-packages/test/#make-a-test-fail","text":"Given a file named \"foo.test.pen\" with: import Test'Assert Foo = \\() none | error { Assert'Fail() } When I run pen test Then the exit status should be 1.","title":"Make a test fail"},{"location":"examples/syntax/block/","text":"Block Background Given a file named \"pen.json\" with: { \"type\": \"library\", \"dependencies\": {} } Define a variable Given a file named \"Foo.pen\" with: f = \\(x number) number { y = x y } When I run pen build Then the exit status should be 0. Call a function Given a file named \"Foo.pen\" with: f = \\() none { none } g = \\() none { f() none } When I run pen build Then the exit status should be 0. Use if expression Given a file named \"Foo.pen\" with: f = \\() none { none } g = \\() none { none } h = \\(x boolean) none { if x { f() } else { g() } none } When I run pen build Then the exit status should be 0.","title":"Block"},{"location":"examples/syntax/block/#block","text":"","title":"Block"},{"location":"examples/syntax/block/#background","text":"Given a file named \"pen.json\" with: { \"type\": \"library\", \"dependencies\": {} }","title":"Background"},{"location":"examples/syntax/block/#define-a-variable","text":"Given a file named \"Foo.pen\" with: f = \\(x number) number { y = x y } When I run pen build Then the exit status should be 0.","title":"Define a variable"},{"location":"examples/syntax/block/#call-a-function","text":"Given a file named \"Foo.pen\" with: f = \\() none { none } g = \\() none { f() none } When I run pen build Then the exit status should be 0.","title":"Call a function"},{"location":"examples/syntax/block/#use-if-expression","text":"Given a file named \"Foo.pen\" with: f = \\() none { none } g = \\() none { none } h = \\(x boolean) none { if x { f() } else { g() } none } When I run pen build Then the exit status should be 0.","title":"Use if expression"},{"location":"examples/syntax/concurrency/","text":"Concurrency Background Given a file named \"pen.json\" with: { \"type\": \"application\", \"dependencies\": { \"Os\": \"pen:///os\" } } Use spawn function Given a file named \"main.pen\" with: main = \\(ctx context) none { f = go(\\() none { none }) f() } When I successfully run pen build Then I successfully run ./app . Use race function Given a file named \"main.pen\" with: import Os'Process main = \\(ctx context) none { xs = race([[none] [none none]]) if [x, ...xs] = xs { x() } else { Process'Exit(ctx.Os, 1) } } When I successfully run pen build Then I successfully run ./app . Use race function with multiple lists Given a file named \"main.pen\" with: import Os'Process main = \\(ctx context) none { xs = race([[none] [none none], [none none]]) if [x, ...xs] = xs { x() } else { Process'Exit(ctx.Os, 1) } } When I successfully run pen build Then I successfully run ./app . Use race function to get the first result Given a file named \"main.pen\" with: import Os'Context { Context } import Os'Process import Os'Time main = \\(ctx context) none { xs = race([[boolean] [boolean (\\() boolean { loop(ctx.Os) false })()], [boolean true], ]) if [x, ...xs] = xs { if x() { none } else { Process'Exit(ctx.Os, 1) } } else { Process'Exit(ctx.Os, 1) } } loop = \\(ctx Context) none { Time'Sleep(ctx, 1) loop(ctx) } When I successfully run pen build Then I successfully run ./app . Use race function and get all elements Given a file named \"main.pen\" with: import Os'Process main = \\(ctx context) none { xs = race([[none] [none none], [none none]]) if xs == [none none, none] { none } else { Process'Exit(ctx.Os, 1) } } When I successfully run pen build Then I successfully run ./app .","title":"Concurrency"},{"location":"examples/syntax/concurrency/#concurrency","text":"","title":"Concurrency"},{"location":"examples/syntax/concurrency/#background","text":"Given a file named \"pen.json\" with: { \"type\": \"application\", \"dependencies\": { \"Os\": \"pen:///os\" } }","title":"Background"},{"location":"examples/syntax/concurrency/#use-spawn-function","text":"Given a file named \"main.pen\" with: main = \\(ctx context) none { f = go(\\() none { none }) f() } When I successfully run pen build Then I successfully run ./app .","title":"Use spawn function"},{"location":"examples/syntax/concurrency/#use-race-function","text":"Given a file named \"main.pen\" with: import Os'Process main = \\(ctx context) none { xs = race([[none] [none none]]) if [x, ...xs] = xs { x() } else { Process'Exit(ctx.Os, 1) } } When I successfully run pen build Then I successfully run ./app .","title":"Use race function"},{"location":"examples/syntax/concurrency/#use-race-function-with-multiple-lists","text":"Given a file named \"main.pen\" with: import Os'Process main = \\(ctx context) none { xs = race([[none] [none none], [none none]]) if [x, ...xs] = xs { x() } else { Process'Exit(ctx.Os, 1) } } When I successfully run pen build Then I successfully run ./app .","title":"Use race function with multiple lists"},{"location":"examples/syntax/concurrency/#use-race-function-to-get-the-first-result","text":"Given a file named \"main.pen\" with: import Os'Context { Context } import Os'Process import Os'Time main = \\(ctx context) none { xs = race([[boolean] [boolean (\\() boolean { loop(ctx.Os) false })()], [boolean true], ]) if [x, ...xs] = xs { if x() { none } else { Process'Exit(ctx.Os, 1) } } else { Process'Exit(ctx.Os, 1) } } loop = \\(ctx Context) none { Time'Sleep(ctx, 1) loop(ctx) } When I successfully run pen build Then I successfully run ./app .","title":"Use race function to get the first result"},{"location":"examples/syntax/concurrency/#use-race-function-and-get-all-elements","text":"Given a file named \"main.pen\" with: import Os'Process main = \\(ctx context) none { xs = race([[none] [none none], [none none]]) if xs == [none none, none] { none } else { Process'Exit(ctx.Os, 1) } } When I successfully run pen build Then I successfully run ./app .","title":"Use race function and get all elements"},{"location":"examples/types/any/","text":"Any Background Given a file named \"pen.json\" with: { \"type\": \"library\", \"dependencies\": {} } Use an any type Given a file named \"Foo.pen\" with: f = \\() any { 42 } When I run pen build Then the exit status should be 0. Downcast an any type Given a file named \"Foo.pen\" with: f = \\(x any) number { if x = x as number { x } else { 0 } } When I run pen build Then the exit status should be 0.","title":"Any"},{"location":"examples/types/any/#any","text":"","title":"Any"},{"location":"examples/types/any/#background","text":"Given a file named \"pen.json\" with: { \"type\": \"library\", \"dependencies\": {} }","title":"Background"},{"location":"examples/types/any/#use-an-any-type","text":"Given a file named \"Foo.pen\" with: f = \\() any { 42 } When I run pen build Then the exit status should be 0.","title":"Use an any type"},{"location":"examples/types/any/#downcast-an-any-type","text":"Given a file named \"Foo.pen\" with: f = \\(x any) number { if x = x as number { x } else { 0 } } When I run pen build Then the exit status should be 0.","title":"Downcast an any type"},{"location":"examples/types/boolean/","text":"Boolean Background Given a file named \"pen.json\" with: { \"type\": \"library\", \"dependencies\": {} } Use boolean literals Given a file named \"Foo.pen\" with: f = \\() boolean { true } g = \\() boolean { false } When I run pen build Then the exit status should be 0. Use an and operation Given a file named \"Foo.pen\" with: f = \\() boolean { true & false } When I run pen build Then the exit status should be 0. Use an or operation Given a file named \"Foo.pen\" with: f = \\() boolean { true | false } When I run pen build Then the exit status should be 0. Use a not operation Given a file named \"Foo.pen\" with: f = \\() boolean { !true } When I run pen build Then the exit status should be 0. Use an if expression Given a file named \"Foo.pen\" with: f = \\() number { if true { 1 } else { 0 } } When I run pen build Then the exit status should be 0.","title":"Boolean"},{"location":"examples/types/boolean/#boolean","text":"","title":"Boolean"},{"location":"examples/types/boolean/#background","text":"Given a file named \"pen.json\" with: { \"type\": \"library\", \"dependencies\": {} }","title":"Background"},{"location":"examples/types/boolean/#use-boolean-literals","text":"Given a file named \"Foo.pen\" with: f = \\() boolean { true } g = \\() boolean { false } When I run pen build Then the exit status should be 0.","title":"Use boolean literals"},{"location":"examples/types/boolean/#use-an-and-operation","text":"Given a file named \"Foo.pen\" with: f = \\() boolean { true & false } When I run pen build Then the exit status should be 0.","title":"Use an and operation"},{"location":"examples/types/boolean/#use-an-or-operation","text":"Given a file named \"Foo.pen\" with: f = \\() boolean { true | false } When I run pen build Then the exit status should be 0.","title":"Use an or operation"},{"location":"examples/types/boolean/#use-a-not-operation","text":"Given a file named \"Foo.pen\" with: f = \\() boolean { !true } When I run pen build Then the exit status should be 0.","title":"Use a not operation"},{"location":"examples/types/boolean/#use-an-if-expression","text":"Given a file named \"Foo.pen\" with: f = \\() number { if true { 1 } else { 0 } } When I run pen build Then the exit status should be 0.","title":"Use an if expression"},{"location":"examples/types/error/","text":"Error Background Given a file named \"pen.json\" with: { \"type\": \"library\", \"dependencies\": {} } Call an error function Given a file named \"Foo.pen\" with: f = \\() error { error(none) } When I run pen build Then the exit status should be 0. Call a source function Given a file named \"Foo.pen\" with: f = \\(e error) any { source(e) } When I run pen build Then the exit status should be 0. Use a try operator Given a file named \"Foo.pen\" with: f = \\(x number | error) number | error { x? + 1 } When I run pen build Then the exit status should be 0. Use a try operator with a union type Given a file named \"Foo.pen\" with: f = \\(x number | none | error) number | error { if x = x? as number { x + 1 } else if none { 0 } } When I run pen build Then the exit status should be 0.","title":"Error"},{"location":"examples/types/error/#error","text":"","title":"Error"},{"location":"examples/types/error/#background","text":"Given a file named \"pen.json\" with: { \"type\": \"library\", \"dependencies\": {} }","title":"Background"},{"location":"examples/types/error/#call-an-error-function","text":"Given a file named \"Foo.pen\" with: f = \\() error { error(none) } When I run pen build Then the exit status should be 0.","title":"Call an error function"},{"location":"examples/types/error/#call-a-source-function","text":"Given a file named \"Foo.pen\" with: f = \\(e error) any { source(e) } When I run pen build Then the exit status should be 0.","title":"Call a source function"},{"location":"examples/types/error/#use-a-try-operator","text":"Given a file named \"Foo.pen\" with: f = \\(x number | error) number | error { x? + 1 } When I run pen build Then the exit status should be 0.","title":"Use a try operator"},{"location":"examples/types/error/#use-a-try-operator-with-a-union-type","text":"Given a file named \"Foo.pen\" with: f = \\(x number | none | error) number | error { if x = x? as number { x + 1 } else if none { 0 } } When I run pen build Then the exit status should be 0.","title":"Use a try operator with a union type"},{"location":"examples/types/function/","text":"Function Background Given a file named \"pen.json\" with: { \"type\": \"library\", \"dependencies\": {} } Define a function Given a file named \"Foo.pen\" with: f = \\(x number) number { x } When I run pen build Then the exit status should be 0. Call a function with no argument Given a file named \"Foo.pen\" with: f = \\() number { f() } When I run pen build Then the exit status should be 0. Call a function with an argument Given a file named \"Foo.pen\" with: f = \\(x number) number { f(x) } When I run pen build Then the exit status should be 0. Call a function with two arguments Given a file named \"Foo.pen\" with: f = \\(x number, y number) number { f(x, y) } When I run pen build Then the exit status should be 0. Define a closure Given a file named \"Foo.pen\" with: f = \\(x number) \\(number) number { \\(y number) number { x + y } } When I run pen build Then the exit status should be 0.","title":"Function"},{"location":"examples/types/function/#function","text":"","title":"Function"},{"location":"examples/types/function/#background","text":"Given a file named \"pen.json\" with: { \"type\": \"library\", \"dependencies\": {} }","title":"Background"},{"location":"examples/types/function/#define-a-function","text":"Given a file named \"Foo.pen\" with: f = \\(x number) number { x } When I run pen build Then the exit status should be 0.","title":"Define a function"},{"location":"examples/types/function/#call-a-function-with-no-argument","text":"Given a file named \"Foo.pen\" with: f = \\() number { f() } When I run pen build Then the exit status should be 0.","title":"Call a function with no argument"},{"location":"examples/types/function/#call-a-function-with-an-argument","text":"Given a file named \"Foo.pen\" with: f = \\(x number) number { f(x) } When I run pen build Then the exit status should be 0.","title":"Call a function with an argument"},{"location":"examples/types/function/#call-a-function-with-two-arguments","text":"Given a file named \"Foo.pen\" with: f = \\(x number, y number) number { f(x, y) } When I run pen build Then the exit status should be 0.","title":"Call a function with two arguments"},{"location":"examples/types/function/#define-a-closure","text":"Given a file named \"Foo.pen\" with: f = \\(x number) \\(number) number { \\(y number) number { x + y } } When I run pen build Then the exit status should be 0.","title":"Define a closure"},{"location":"examples/types/list/","text":"List Background Given a file named \"pen.json\" with: { \"type\": \"library\", \"dependencies\": {} } Create an empty list Given a file named \"Foo.pen\" with: f = \\() [number] { [number] } When I run pen build Then the exit status should be 0. Create a list with an element Given a file named \"Foo.pen\" with: f = \\() [number] { [number 1] } When I run pen build Then the exit status should be 0. Create a list with two elements Given a file named \"Foo.pen\" with: f = \\() [number] { [number 1, 2] } When I run pen build Then the exit status should be 0. Join lists Given a file named \"Foo.pen\" with: f = \\(xs [number]) [number] { [number ...xs, ...xs] } When I run pen build Then the exit status should be 0. Create a list of a union type Given a file named \"Foo.pen\" with: f = \\() [number | none] { [number | none 1, none] } When I run pen build Then the exit status should be 0. Coerce elements of a spread list Given a file named \"Foo.pen\" with: f = \\(xs [number]) [number | none] { [number | none ...xs] } When I run pen build Then the exit status should be 0. Use if-list expression Given a file named \"Foo.pen\" with: f = \\(xs [number]) [number] { if [y, ...ys] = xs { [number y(), ...ys] } else { [number] } } When I run pen build Then the exit status should be 0. Use list comprehension Given a file named \"Foo.pen\" with: f = \\(xs [number]) [number] { [number x() + 42 for x in xs] } When I run pen build Then the exit status should be 0. Permutate lists Given a file named \"Foo.pen\" with: f = \\(xs [number], ys [number]) [number] { [number x() + y() for x in xs for y in ys] } When I run pen build Then the exit status should be 0. Flatten a list Given a file named \"Foo.pen\" with: f = \\(xs [[number]]) [number] { [number y() for y in x() for x in xs] } When I run pen build Then the exit status should be 0. Filter a list Given a file named \"Foo.pen\" with: f = \\(xs [number]) [number] { [number x() for x in xs if x() < 42] } When I run pen build Then the exit status should be 0. Zip lists Given a file named \"Foo.pen\" with: f = \\(xs [number], ys [number]) [number] { [number x() + y() for x, y in xs, ys] } When I run pen build Then the exit status should be 0. Get a size of a list Given a file named \"Foo.pen\" with: f = \\(xs [none]) number { size(xs) } When I run pen build Then the exit status should be 0.","title":"List"},{"location":"examples/types/list/#list","text":"","title":"List"},{"location":"examples/types/list/#background","text":"Given a file named \"pen.json\" with: { \"type\": \"library\", \"dependencies\": {} }","title":"Background"},{"location":"examples/types/list/#create-an-empty-list","text":"Given a file named \"Foo.pen\" with: f = \\() [number] { [number] } When I run pen build Then the exit status should be 0.","title":"Create an empty list"},{"location":"examples/types/list/#create-a-list-with-an-element","text":"Given a file named \"Foo.pen\" with: f = \\() [number] { [number 1] } When I run pen build Then the exit status should be 0.","title":"Create a list with an element"},{"location":"examples/types/list/#create-a-list-with-two-elements","text":"Given a file named \"Foo.pen\" with: f = \\() [number] { [number 1, 2] } When I run pen build Then the exit status should be 0.","title":"Create a list with two elements"},{"location":"examples/types/list/#join-lists","text":"Given a file named \"Foo.pen\" with: f = \\(xs [number]) [number] { [number ...xs, ...xs] } When I run pen build Then the exit status should be 0.","title":"Join lists"},{"location":"examples/types/list/#create-a-list-of-a-union-type","text":"Given a file named \"Foo.pen\" with: f = \\() [number | none] { [number | none 1, none] } When I run pen build Then the exit status should be 0.","title":"Create a list of a union type"},{"location":"examples/types/list/#coerce-elements-of-a-spread-list","text":"Given a file named \"Foo.pen\" with: f = \\(xs [number]) [number | none] { [number | none ...xs] } When I run pen build Then the exit status should be 0.","title":"Coerce elements of a spread list"},{"location":"examples/types/list/#use-if-list-expression","text":"Given a file named \"Foo.pen\" with: f = \\(xs [number]) [number] { if [y, ...ys] = xs { [number y(), ...ys] } else { [number] } } When I run pen build Then the exit status should be 0.","title":"Use if-list expression"},{"location":"examples/types/list/#use-list-comprehension","text":"Given a file named \"Foo.pen\" with: f = \\(xs [number]) [number] { [number x() + 42 for x in xs] } When I run pen build Then the exit status should be 0.","title":"Use list comprehension"},{"location":"examples/types/list/#permutate-lists","text":"Given a file named \"Foo.pen\" with: f = \\(xs [number], ys [number]) [number] { [number x() + y() for x in xs for y in ys] } When I run pen build Then the exit status should be 0.","title":"Permutate lists"},{"location":"examples/types/list/#flatten-a-list","text":"Given a file named \"Foo.pen\" with: f = \\(xs [[number]]) [number] { [number y() for y in x() for x in xs] } When I run pen build Then the exit status should be 0.","title":"Flatten a list"},{"location":"examples/types/list/#filter-a-list","text":"Given a file named \"Foo.pen\" with: f = \\(xs [number]) [number] { [number x() for x in xs if x() < 42] } When I run pen build Then the exit status should be 0.","title":"Filter a list"},{"location":"examples/types/list/#zip-lists","text":"Given a file named \"Foo.pen\" with: f = \\(xs [number], ys [number]) [number] { [number x() + y() for x, y in xs, ys] } When I run pen build Then the exit status should be 0.","title":"Zip lists"},{"location":"examples/types/list/#get-a-size-of-a-list","text":"Given a file named \"Foo.pen\" with: f = \\(xs [none]) number { size(xs) } When I run pen build Then the exit status should be 0.","title":"Get a size of a list"},{"location":"examples/types/map/","text":"Map Background Given a file named \"pen.json\" with: { \"type\": \"library\", \"dependencies\": {} } Create an empty map Given a file named \"Foo.pen\" with: f = \\() {string: number} { {string: number} } When I successfully run pen build Then the exit status should be 0. Create a map with an entry Given a file named \"Foo.pen\" with: f = \\() {string: number} { {string: number \"foo\": 42} } When I successfully run pen build Then the exit status should be 0. Create a map with two elements Given a file named \"Foo.pen\" with: f = \\() {string: number} { {string: number \"foo\": 1, \"bar\": 2} } When I successfully run pen build Then the exit status should be 0. Get a value in a map Given a file named \"Foo.pen\" with: f = \\(xs {string: number}) number { if x = xs[\"foo\"] { x } else { 0 } } When I successfully run pen build Then the exit status should be 0. Merge maps Given a file named \"Foo.pen\" with: f = \\(xs {string: number}) {string: number} { {string: number ...xs, ...xs} } When I successfully run pen build Then the exit status should be 0. Merge a map of different types Given a file named \"Foo.pen\" with: f = \\(xs {string: number}) {string | none: number | none} { {string | none: number | none ...xs} } When I successfully run pen build Then the exit status should be 0. Create a map of a union type key Given a file named \"Foo.pen\" with: f = \\() {string|none:number} { {string|none:number \"foo\": 1, none: 2} } When I successfully run pen build Then the exit status should be 0. Create a map of a union type value Given a file named \"Foo.pen\" with: f = \\() {string: number | none} { {string: number | none \"foo\": 42, \"bar\": none} } When I successfully run pen build Then the exit status should be 0. Iterate map keys Given a file named \"Foo.pen\" with: f = \\(xs {string: number}) [string] { keys(xs) } When I successfully run pen build Then the exit status should be 0. Iterate map values Given a file named \"Foo.pen\" with: f = \\(xs {string: number}) [number] { values(xs) } When I successfully run pen build Then the exit status should be 0. Get a size of a map Given a file named \"Foo.pen\" with: f = \\(xs {string: number}) number { size(xs) } When I run pen build Then the exit status should be 0. Delete an entry of a map Given a file named \"Foo.pen\" with: f = \\(xs {string: number}) {string: number} { delete(xs, \"foo\") } When I run pen build Then the exit status should be 0.","title":"Map"},{"location":"examples/types/map/#map","text":"","title":"Map"},{"location":"examples/types/map/#background","text":"Given a file named \"pen.json\" with: { \"type\": \"library\", \"dependencies\": {} }","title":"Background"},{"location":"examples/types/map/#create-an-empty-map","text":"Given a file named \"Foo.pen\" with: f = \\() {string: number} { {string: number} } When I successfully run pen build Then the exit status should be 0.","title":"Create an empty map"},{"location":"examples/types/map/#create-a-map-with-an-entry","text":"Given a file named \"Foo.pen\" with: f = \\() {string: number} { {string: number \"foo\": 42} } When I successfully run pen build Then the exit status should be 0.","title":"Create a map with an entry"},{"location":"examples/types/map/#create-a-map-with-two-elements","text":"Given a file named \"Foo.pen\" with: f = \\() {string: number} { {string: number \"foo\": 1, \"bar\": 2} } When I successfully run pen build Then the exit status should be 0.","title":"Create a map with two elements"},{"location":"examples/types/map/#get-a-value-in-a-map","text":"Given a file named \"Foo.pen\" with: f = \\(xs {string: number}) number { if x = xs[\"foo\"] { x } else { 0 } } When I successfully run pen build Then the exit status should be 0.","title":"Get a value in a map"},{"location":"examples/types/map/#merge-maps","text":"Given a file named \"Foo.pen\" with: f = \\(xs {string: number}) {string: number} { {string: number ...xs, ...xs} } When I successfully run pen build Then the exit status should be 0.","title":"Merge maps"},{"location":"examples/types/map/#merge-a-map-of-different-types","text":"Given a file named \"Foo.pen\" with: f = \\(xs {string: number}) {string | none: number | none} { {string | none: number | none ...xs} } When I successfully run pen build Then the exit status should be 0.","title":"Merge a map of different types"},{"location":"examples/types/map/#create-a-map-of-a-union-type-key","text":"Given a file named \"Foo.pen\" with: f = \\() {string|none:number} { {string|none:number \"foo\": 1, none: 2} } When I successfully run pen build Then the exit status should be 0.","title":"Create a map of a union type key"},{"location":"examples/types/map/#create-a-map-of-a-union-type-value","text":"Given a file named \"Foo.pen\" with: f = \\() {string: number | none} { {string: number | none \"foo\": 42, \"bar\": none} } When I successfully run pen build Then the exit status should be 0.","title":"Create a map of a union type value"},{"location":"examples/types/map/#iterate-map-keys","text":"Given a file named \"Foo.pen\" with: f = \\(xs {string: number}) [string] { keys(xs) } When I successfully run pen build Then the exit status should be 0.","title":"Iterate map keys"},{"location":"examples/types/map/#iterate-map-values","text":"Given a file named \"Foo.pen\" with: f = \\(xs {string: number}) [number] { values(xs) } When I successfully run pen build Then the exit status should be 0.","title":"Iterate map values"},{"location":"examples/types/map/#get-a-size-of-a-map","text":"Given a file named \"Foo.pen\" with: f = \\(xs {string: number}) number { size(xs) } When I run pen build Then the exit status should be 0.","title":"Get a size of a map"},{"location":"examples/types/map/#delete-an-entry-of-a-map","text":"Given a file named \"Foo.pen\" with: f = \\(xs {string: number}) {string: number} { delete(xs, \"foo\") } When I run pen build Then the exit status should be 0.","title":"Delete an entry of a map"},{"location":"examples/types/none/","text":"None Background Given a file named \"pen.json\" with: { \"type\": \"library\", \"dependencies\": {} } Use a none literal Given a file named \"Foo.pen\" with: f = \\() none { none } When I run pen build Then the exit status should be 0.","title":"None"},{"location":"examples/types/none/#none","text":"","title":"None"},{"location":"examples/types/none/#background","text":"Given a file named \"pen.json\" with: { \"type\": \"library\", \"dependencies\": {} }","title":"Background"},{"location":"examples/types/none/#use-a-none-literal","text":"Given a file named \"Foo.pen\" with: f = \\() none { none } When I run pen build Then the exit status should be 0.","title":"Use a none literal"},{"location":"examples/types/number/","text":"Number Background Given a file named \"pen.json\" with: { \"type\": \"library\", \"dependencies\": {} } Use a number literal Given a file named \"Foo.pen\" with: f = \\() number { 42 } When I run pen build Then the exit status should be 0. Use arithmetic operators Given a file named \"Foo.pen\" with: f = \\() number { 1 + 2 - 3 * 4 / 5 } When I run pen build Then the exit status should be 0. Use equality operators Given a file named \"Foo.pen\" with: f = \\() boolean { 0 == 0 } g = \\() boolean { 0 != 0 } When I run pen build Then the exit status should be 0. Use order operators Given a file named \"Foo.pen\" with: f = \\() boolean { 0 < 0 } g = \\() boolean { 0 <= 0 } h = \\() boolean { 0 > 0 } i = \\() boolean { 0 >= 0 } When I run pen build Then the exit status should be 0.","title":"Number"},{"location":"examples/types/number/#number","text":"","title":"Number"},{"location":"examples/types/number/#background","text":"Given a file named \"pen.json\" with: { \"type\": \"library\", \"dependencies\": {} }","title":"Background"},{"location":"examples/types/number/#use-a-number-literal","text":"Given a file named \"Foo.pen\" with: f = \\() number { 42 } When I run pen build Then the exit status should be 0.","title":"Use a number literal"},{"location":"examples/types/number/#use-arithmetic-operators","text":"Given a file named \"Foo.pen\" with: f = \\() number { 1 + 2 - 3 * 4 / 5 } When I run pen build Then the exit status should be 0.","title":"Use arithmetic operators"},{"location":"examples/types/number/#use-equality-operators","text":"Given a file named \"Foo.pen\" with: f = \\() boolean { 0 == 0 } g = \\() boolean { 0 != 0 } When I run pen build Then the exit status should be 0.","title":"Use equality operators"},{"location":"examples/types/number/#use-order-operators","text":"Given a file named \"Foo.pen\" with: f = \\() boolean { 0 < 0 } g = \\() boolean { 0 <= 0 } h = \\() boolean { 0 > 0 } i = \\() boolean { 0 >= 0 } When I run pen build Then the exit status should be 0.","title":"Use order operators"},{"location":"examples/types/polymorphism/","text":"Polymorphism Background Given a file named \"pen.json\" with: { \"type\": \"library\", \"dependencies\": {} } Use an equal operator Given a file named \"Foo.pen\" with: f = \\(x number | none) boolean { x == none } When I run pen build Then the exit status should be 0. Use a not-equal operator Given a file named \"Foo.pen\" with: f = \\(x number | none) boolean { x != none } When I run pen build Then the exit status should be 0. Compare unions Given a file named \"Foo.pen\" with: f = \\(x number | none, y number | none) boolean { x == y } When I run pen build Then the exit status should be 0. Compare a union and none Given a file named \"Foo.pen\" with: f = \\(x number | none) boolean { x == none } When I run pen build Then the exit status should be 0.","title":"Polymorphism"},{"location":"examples/types/polymorphism/#polymorphism","text":"","title":"Polymorphism"},{"location":"examples/types/polymorphism/#background","text":"Given a file named \"pen.json\" with: { \"type\": \"library\", \"dependencies\": {} }","title":"Background"},{"location":"examples/types/polymorphism/#use-an-equal-operator","text":"Given a file named \"Foo.pen\" with: f = \\(x number | none) boolean { x == none } When I run pen build Then the exit status should be 0.","title":"Use an equal operator"},{"location":"examples/types/polymorphism/#use-a-not-equal-operator","text":"Given a file named \"Foo.pen\" with: f = \\(x number | none) boolean { x != none } When I run pen build Then the exit status should be 0.","title":"Use a not-equal operator"},{"location":"examples/types/polymorphism/#compare-unions","text":"Given a file named \"Foo.pen\" with: f = \\(x number | none, y number | none) boolean { x == y } When I run pen build Then the exit status should be 0.","title":"Compare unions"},{"location":"examples/types/polymorphism/#compare-a-union-and-none","text":"Given a file named \"Foo.pen\" with: f = \\(x number | none) boolean { x == none } When I run pen build Then the exit status should be 0.","title":"Compare a union and none"},{"location":"examples/types/record/","text":"Record Background Given a file named \"pen.json\" with: { \"type\": \"library\", \"dependencies\": {} } Create a record with a field Given a file named \"Foo.pen\" with: type r { x number } f = \\() r { r{x: 42} } When I run pen build Then the exit status should be 0. Create a record with two fields Given a file named \"Foo.pen\" with: type r { x number y none } f = \\() r { r{x: 42, y: none} } When I run pen build Then the exit status should be 0. Create a record with no field Given a file named \"Foo.pen\" with: type r {} f = \\() r { r{} } When I run pen build Then the exit status should be 0. Update a record Given a file named \"Foo.pen\" with: type r { x number y none } f = \\(x r) r { r{...x, y: none} } When I run pen build Then the exit status should be 0. Get a field in a record Given a file named \"Foo.pen\" with: type r { x number } f = \\(x r) number { x.x } When I run pen build Then the exit status should be 0. Use an equal operator Given a file named \"Foo.pen\" with: type r { x number } f = \\(x r, y r) boolean { x == y } When I run pen build Then the exit status should be 0. Use a not-equal operator Given a file named \"Foo.pen\" with: type r { x number } f = \\(x r, y r) boolean { x == y } When I run pen build Then the exit status should be 0. Propagate openness of a record Given a file named \"Foo.pen\" with: type Foo { X number } And a file named \"Bar.pen\" with: import 'Foo Bar = \\() Foo'Foo { Foo'Foo{X: 42} } And a file named \"Baz.pen\" with: import 'Bar f = \\() number { Bar'Bar().X } When I run pen build Then the exit status should be 0.","title":"Record"},{"location":"examples/types/record/#record","text":"","title":"Record"},{"location":"examples/types/record/#background","text":"Given a file named \"pen.json\" with: { \"type\": \"library\", \"dependencies\": {} }","title":"Background"},{"location":"examples/types/record/#create-a-record-with-a-field","text":"Given a file named \"Foo.pen\" with: type r { x number } f = \\() r { r{x: 42} } When I run pen build Then the exit status should be 0.","title":"Create a record with a field"},{"location":"examples/types/record/#create-a-record-with-two-fields","text":"Given a file named \"Foo.pen\" with: type r { x number y none } f = \\() r { r{x: 42, y: none} } When I run pen build Then the exit status should be 0.","title":"Create a record with two fields"},{"location":"examples/types/record/#create-a-record-with-no-field","text":"Given a file named \"Foo.pen\" with: type r {} f = \\() r { r{} } When I run pen build Then the exit status should be 0.","title":"Create a record with no field"},{"location":"examples/types/record/#update-a-record","text":"Given a file named \"Foo.pen\" with: type r { x number y none } f = \\(x r) r { r{...x, y: none} } When I run pen build Then the exit status should be 0.","title":"Update a record"},{"location":"examples/types/record/#get-a-field-in-a-record","text":"Given a file named \"Foo.pen\" with: type r { x number } f = \\(x r) number { x.x } When I run pen build Then the exit status should be 0.","title":"Get a field in a record"},{"location":"examples/types/record/#use-an-equal-operator","text":"Given a file named \"Foo.pen\" with: type r { x number } f = \\(x r, y r) boolean { x == y } When I run pen build Then the exit status should be 0.","title":"Use an equal operator"},{"location":"examples/types/record/#use-a-not-equal-operator","text":"Given a file named \"Foo.pen\" with: type r { x number } f = \\(x r, y r) boolean { x == y } When I run pen build Then the exit status should be 0.","title":"Use a not-equal operator"},{"location":"examples/types/record/#propagate-openness-of-a-record","text":"Given a file named \"Foo.pen\" with: type Foo { X number } And a file named \"Bar.pen\" with: import 'Foo Bar = \\() Foo'Foo { Foo'Foo{X: 42} } And a file named \"Baz.pen\" with: import 'Bar f = \\() number { Bar'Bar().X } When I run pen build Then the exit status should be 0.","title":"Propagate openness of a record"},{"location":"examples/types/stream/","text":"List as stream Background Given a file named \"pen.json\" with: { \"type\": \"application\", \"dependencies\": { \"Os\": \"pen:///os\" } } And a file named \"Hello.pen\" with: import Os'Context { Context } import Os'File Hello = \\(ctx Context) none { _ = File'Write(ctx, File'StdOut(), \"hello\") none } Evaluate an element lazily Given a file named \"main.pen\" with: import 'Hello main = \\(ctx context) none { [none Hello'Hello(ctx.Os)] none } When I successfully run pen build Then I successfully run ./app And the stdout from \"./app\" should not contain \"hello\". Evaluate an element lazily but only once Given a file named \"main.pen\" with: import Os'Process import 'Hello main = \\(ctx context) none { if [x, ...xs] = [none Hello'Hello(ctx.Os)] { x() x() none } else { Process'Exit(ctx.Os, 1) } } When I successfully run pen build Then I successfully run ./app And the stdout from \"./app\" should contain exactly \"hello\". Evaluate multiple elements lazily Given a file named \"main.pen\" with: import Os'Context { Context } import 'Hello foo = \\(ctx Context) [none] { Hello'Hello(ctx) [none] } main = \\(ctx context) none { [none ...foo(ctx.Os)] none } When I successfully run pen build Then I successfully run ./app And the stdout from \"./app\" should not contain \"hello\". Evaluate multiple elements lazily but only once Given a file named \"main.pen\" with: import Os'Context { Context } import Os'Process import 'Hello foo = \\(ctx Context) [none] { Hello'Hello(ctx) [none] } main = \\(ctx context) none { xs = [none ...foo(ctx.Os)] if [x, ...xs] = xs { Process'Exit(ctx.Os, 1) } else { if [x, ...xs] = xs { Process'Exit(ctx.Os, 1) } else { none } } } When I successfully run pen build Then I successfully run ./app And the stdout from \"./app\" should contain exactly \"hello\".","title":"List as stream"},{"location":"examples/types/stream/#list-as-stream","text":"","title":"List as stream"},{"location":"examples/types/stream/#background","text":"Given a file named \"pen.json\" with: { \"type\": \"application\", \"dependencies\": { \"Os\": \"pen:///os\" } } And a file named \"Hello.pen\" with: import Os'Context { Context } import Os'File Hello = \\(ctx Context) none { _ = File'Write(ctx, File'StdOut(), \"hello\") none }","title":"Background"},{"location":"examples/types/stream/#evaluate-an-element-lazily","text":"Given a file named \"main.pen\" with: import 'Hello main = \\(ctx context) none { [none Hello'Hello(ctx.Os)] none } When I successfully run pen build Then I successfully run ./app And the stdout from \"./app\" should not contain \"hello\".","title":"Evaluate an element lazily"},{"location":"examples/types/stream/#evaluate-an-element-lazily-but-only-once","text":"Given a file named \"main.pen\" with: import Os'Process import 'Hello main = \\(ctx context) none { if [x, ...xs] = [none Hello'Hello(ctx.Os)] { x() x() none } else { Process'Exit(ctx.Os, 1) } } When I successfully run pen build Then I successfully run ./app And the stdout from \"./app\" should contain exactly \"hello\".","title":"Evaluate an element lazily but only once"},{"location":"examples/types/stream/#evaluate-multiple-elements-lazily","text":"Given a file named \"main.pen\" with: import Os'Context { Context } import 'Hello foo = \\(ctx Context) [none] { Hello'Hello(ctx) [none] } main = \\(ctx context) none { [none ...foo(ctx.Os)] none } When I successfully run pen build Then I successfully run ./app And the stdout from \"./app\" should not contain \"hello\".","title":"Evaluate multiple elements lazily"},{"location":"examples/types/stream/#evaluate-multiple-elements-lazily-but-only-once","text":"Given a file named \"main.pen\" with: import Os'Context { Context } import Os'Process import 'Hello foo = \\(ctx Context) [none] { Hello'Hello(ctx) [none] } main = \\(ctx context) none { xs = [none ...foo(ctx.Os)] if [x, ...xs] = xs { Process'Exit(ctx.Os, 1) } else { if [x, ...xs] = xs { Process'Exit(ctx.Os, 1) } else { none } } } When I successfully run pen build Then I successfully run ./app And the stdout from \"./app\" should contain exactly \"hello\".","title":"Evaluate multiple elements lazily but only once"},{"location":"examples/types/string/","text":"String Background Given a file named \"pen.json\" with: { \"type\": \"library\", \"dependencies\": {} } Use a string literal Given a file named \"Foo.pen\" with: f = \\() string { \"foo\" } When I run pen build Then the exit status should be 0. Use equality operators Given a file named \"Foo.pen\" with: f = \\() boolean { \"\" == \"\" } g = \\() boolean { \"\" != \"\" } When I run pen build Then the exit status should be 0. Concatenate strings Given a file named \"Foo.pen\" with: f = \\() string { \"foo\" + \"bar\" } When I run pen build Then the exit status should be 0. Concatenate 3 strings Given a file named \"Foo.pen\" with: f = \\() string { \"foo\" + \"bar\" + \"baz\" } When I run pen build Then the exit status should be 0.","title":"String"},{"location":"examples/types/string/#string","text":"","title":"String"},{"location":"examples/types/string/#background","text":"Given a file named \"pen.json\" with: { \"type\": \"library\", \"dependencies\": {} }","title":"Background"},{"location":"examples/types/string/#use-a-string-literal","text":"Given a file named \"Foo.pen\" with: f = \\() string { \"foo\" } When I run pen build Then the exit status should be 0.","title":"Use a string literal"},{"location":"examples/types/string/#use-equality-operators","text":"Given a file named \"Foo.pen\" with: f = \\() boolean { \"\" == \"\" } g = \\() boolean { \"\" != \"\" } When I run pen build Then the exit status should be 0.","title":"Use equality operators"},{"location":"examples/types/string/#concatenate-strings","text":"Given a file named \"Foo.pen\" with: f = \\() string { \"foo\" + \"bar\" } When I run pen build Then the exit status should be 0.","title":"Concatenate strings"},{"location":"examples/types/string/#concatenate-3-strings","text":"Given a file named \"Foo.pen\" with: f = \\() string { \"foo\" + \"bar\" + \"baz\" } When I run pen build Then the exit status should be 0.","title":"Concatenate 3 strings"},{"location":"examples/types/union/","text":"Union Background Given a file named \"pen.json\" with: { \"type\": \"library\", \"dependencies\": {} } Upcast a number into a union Given a file named \"Foo.pen\" with: f = \\() number | none { 42 } When I run pen build Then the exit status should be 0. Upcast a function into a union Given a file named \"Foo.pen\" with: f = \\() (\\() number) | none { \\() number { 42 } } When I run pen build Then the exit status should be 0. Upcast a list into a union Given a file named \"Foo.pen\" with: f = \\() [number] | none { [number 42] } When I run pen build Then the exit status should be 0. Downcast a union type Given a file named \"Foo.pen\" with: f = \\(x number | none) number { if x = x as number { x } else if none { 0 } } When I run pen build Then the exit status should be 0. Downcast a union type with an else block Given a file named \"Foo.pen\" with: f = \\(x number | none) number { if x = x as none { 0 } else { x } } When I run pen build Then the exit status should be 0. Downcast a union type to another union type Given a file named \"Foo.pen\" with: f = \\(x number | boolean | none) number | none { if x = x as number | none { x } else { none } } When I run pen build Then the exit status should be 0.","title":"Union"},{"location":"examples/types/union/#union","text":"","title":"Union"},{"location":"examples/types/union/#background","text":"Given a file named \"pen.json\" with: { \"type\": \"library\", \"dependencies\": {} }","title":"Background"},{"location":"examples/types/union/#upcast-a-number-into-a-union","text":"Given a file named \"Foo.pen\" with: f = \\() number | none { 42 } When I run pen build Then the exit status should be 0.","title":"Upcast a number into a union"},{"location":"examples/types/union/#upcast-a-function-into-a-union","text":"Given a file named \"Foo.pen\" with: f = \\() (\\() number) | none { \\() number { 42 } } When I run pen build Then the exit status should be 0.","title":"Upcast a function into a union"},{"location":"examples/types/union/#upcast-a-list-into-a-union","text":"Given a file named \"Foo.pen\" with: f = \\() [number] | none { [number 42] } When I run pen build Then the exit status should be 0.","title":"Upcast a list into a union"},{"location":"examples/types/union/#downcast-a-union-type","text":"Given a file named \"Foo.pen\" with: f = \\(x number | none) number { if x = x as number { x } else if none { 0 } } When I run pen build Then the exit status should be 0.","title":"Downcast a union type"},{"location":"examples/types/union/#downcast-a-union-type-with-an-else-block","text":"Given a file named \"Foo.pen\" with: f = \\(x number | none) number { if x = x as none { 0 } else { x } } When I run pen build Then the exit status should be 0.","title":"Downcast a union type with an else block"},{"location":"examples/types/union/#downcast-a-union-type-to-another-union-type","text":"Given a file named \"Foo.pen\" with: f = \\(x number | boolean | none) number | none { if x = x as number | none { x } else { none } } When I run pen build Then the exit status should be 0.","title":"Downcast a union type to another union type"},{"location":"guides/building-an-executable/","text":"Building an executable This page describes how to build an executable of a program written in Pen. It consists of the following steps: Create an application package. Build the package into an executable. Creating an application package Application packages are packages that are built into executables. To create it, you run a pen create command with your application's name (e.g. foo ) in your terminal. pen create foo Then, you should see a foo directory in your current directory. When you go there, you should see a main.pen source file and a pen.json file for package configuration . main.pen : import Os'File main = \\(ctx context) none { _ = File'Write(ctx.Os, File'StdOut(), \"Hello, world!\\n\") none } pen.json : { \"type\": \"application\", \"dependencies\": { \"Os\": \"pen:///os\" } } In this example, the main.pen file contains a program that outputs a text, \"Hello, world!\" in a terminal. And the pen.json configuration file defines a package type of application and its dependencies. Here, it has only a dependency of the Os system package . Building a package into an executable To build the package, you run a pen build command in the package's directory. pen build Then, you will see an executable file named app in the directory. Now, you can run it to see its output, \"Hello, world!\" ./app # -> Hello, world! Next steps Creating a library Using a library Language syntax","title":"Building an executable"},{"location":"guides/building-an-executable/#building-an-executable","text":"This page describes how to build an executable of a program written in Pen. It consists of the following steps: Create an application package. Build the package into an executable.","title":"Building an executable"},{"location":"guides/building-an-executable/#creating-an-application-package","text":"Application packages are packages that are built into executables. To create it, you run a pen create command with your application's name (e.g. foo ) in your terminal. pen create foo Then, you should see a foo directory in your current directory. When you go there, you should see a main.pen source file and a pen.json file for package configuration . main.pen : import Os'File main = \\(ctx context) none { _ = File'Write(ctx.Os, File'StdOut(), \"Hello, world!\\n\") none } pen.json : { \"type\": \"application\", \"dependencies\": { \"Os\": \"pen:///os\" } } In this example, the main.pen file contains a program that outputs a text, \"Hello, world!\" in a terminal. And the pen.json configuration file defines a package type of application and its dependencies. Here, it has only a dependency of the Os system package .","title":"Creating an application package"},{"location":"guides/building-an-executable/#building-a-package-into-an-executable","text":"To build the package, you run a pen build command in the package's directory. pen build Then, you will see an executable file named app in the directory. Now, you can run it to see its output, \"Hello, world!\" ./app # -> Hello, world!","title":"Building a package into an executable"},{"location":"guides/building-an-executable/#next-steps","text":"Creating a library Using a library Language syntax","title":"Next steps"},{"location":"guides/coding-style/","text":"Coding style This page describes the common coding style of programs written in Pen. Spacing Use 2 space characters for indentation. Foo = \\(x number) number { if x == 0 { \"Succeeded!\" } else { \"Failed...\" } } Naming convention Naming is important to keep codes consistent. The language currently has the following naming conventions. Kind Case style Examples Variables Camel case fooBar , FooBar , i , x Functions Camel case fooBar , FooBar , f , g Types Camel case fooBar , FooBar Modules Camel case fooBar , FooBar Module directories Camel case fooBar , FooBar Packages Upper camel case FooBar Global and local names You should use descriptive names for global functions and types. But, on the other hand, you are encouraged to use abbreviated names for local variables as long as that doesn't incur ambiguity. For example, you might use the following abbreviated names: i for index c for requestCount sys for system ctx for context Acronyms Acronyms are treated as single words. Cpu Ast","title":"Coding style"},{"location":"guides/coding-style/#coding-style","text":"This page describes the common coding style of programs written in Pen.","title":"Coding style"},{"location":"guides/coding-style/#spacing","text":"Use 2 space characters for indentation. Foo = \\(x number) number { if x == 0 { \"Succeeded!\" } else { \"Failed...\" } }","title":"Spacing"},{"location":"guides/coding-style/#naming-convention","text":"Naming is important to keep codes consistent. The language currently has the following naming conventions. Kind Case style Examples Variables Camel case fooBar , FooBar , i , x Functions Camel case fooBar , FooBar , f , g Types Camel case fooBar , FooBar Modules Camel case fooBar , FooBar Module directories Camel case fooBar , FooBar Packages Upper camel case FooBar","title":"Naming convention"},{"location":"guides/coding-style/#global-and-local-names","text":"You should use descriptive names for global functions and types. But, on the other hand, you are encouraged to use abbreviated names for local variables as long as that doesn't incur ambiguity. For example, you might use the following abbreviated names: i for index c for requestCount sys for system ctx for context","title":"Global and local names"},{"location":"guides/coding-style/#acronyms","text":"Acronyms are treated as single words. Cpu Ast","title":"Acronyms"},{"location":"guides/concurrency-and-parallelism/","text":"Concurrency and parallelism Concurrent programs use CPU time efficiently without being blocked on I/O or data synchronization. Parallel programs leverage multi-core CPUs to compute things in parallel faster than sequential programs. This page describes how to write concurrent and/or parallel programs in Pen. Built-ins Pen provides several built-in functions for concurrent and parallel programming. go function The go built-in function runs a given function concurrently, and possibly in parallel. future = go(\\() number { computeExpensive(x, y, z) }) The go function returns a function of the same type as the given argument. The returned function returns a resulting value of the function execution. In other languages, such functions returning values computed concurrently when they are ready are also known as futures or promises . The go function may or may not run a given function immediately depending on its implementation. For example, the standard Os system package runs the given function in parallel if multiple CPU cores are available. race function The race built-in function takes multiple lists and merge them into one by evaluating elements in each list concurrently and possibly in parallel. The resulting list contains the elements in the original lists in order of their finished times of computation. Remember that elements in lists are evaluated lazily. zs = race([[number] xs, ys]) This functionality is similar to concurrent queues in other imperative languages, such as channels in Go . Input lists to the race function correspond to producers of elements into the queue, and a consumer of the queue is codes that use elements in the output list. Patterns Task parallelism The go function can run different codes concurrently. For example, the following code runs the functions, computeA and computeB concurrently. Runtimes of applications might execute those functions even in parallel if their system packages allow that. compute = \\(x number, y number) number { z = go(\\() number { computeA(x) }) v = computeB(y) v + z } Data parallelism To run the same computation against many values of the same type, you can use recursion and the go function. computeMany = \\(xs [number]) [number] { if [x, ...xs] = xs { y = go(\\() number { foo(x()) }) ys = computeMany(xs) [number y(), ...ys] } else { [number] } } The example above computes things in order of elements in the original list. However, you might want to see output values of concurrent computation in order of their finished times. By doing that, you can start using the output values as fast as possible without waiting for all computation to be completed. In this case, you can use the race function to reorder elements in the output list by their finished times. compute = \\(xs [number]) [number] { race([[number] [number x()] for x in computeMany(xs)]) } If you want to evaluate elements in multiple lists concurrently, you can simply pass the lists as an argument to the race function. Note that elements in the same lists are not evaluated concurrently although elements in different lists are evaluated concurrently. compute = \\(xs [number], ys [number]) [number] { race([[number] computeMany(xs), computeMany(ys)]) }","title":"Concurrency and parallelism"},{"location":"guides/concurrency-and-parallelism/#concurrency-and-parallelism","text":"Concurrent programs use CPU time efficiently without being blocked on I/O or data synchronization. Parallel programs leverage multi-core CPUs to compute things in parallel faster than sequential programs. This page describes how to write concurrent and/or parallel programs in Pen.","title":"Concurrency and parallelism"},{"location":"guides/concurrency-and-parallelism/#built-ins","text":"Pen provides several built-in functions for concurrent and parallel programming.","title":"Built-ins"},{"location":"guides/concurrency-and-parallelism/#go-function","text":"The go built-in function runs a given function concurrently, and possibly in parallel. future = go(\\() number { computeExpensive(x, y, z) }) The go function returns a function of the same type as the given argument. The returned function returns a resulting value of the function execution. In other languages, such functions returning values computed concurrently when they are ready are also known as futures or promises . The go function may or may not run a given function immediately depending on its implementation. For example, the standard Os system package runs the given function in parallel if multiple CPU cores are available.","title":"go function"},{"location":"guides/concurrency-and-parallelism/#race-function","text":"The race built-in function takes multiple lists and merge them into one by evaluating elements in each list concurrently and possibly in parallel. The resulting list contains the elements in the original lists in order of their finished times of computation. Remember that elements in lists are evaluated lazily. zs = race([[number] xs, ys]) This functionality is similar to concurrent queues in other imperative languages, such as channels in Go . Input lists to the race function correspond to producers of elements into the queue, and a consumer of the queue is codes that use elements in the output list.","title":"race function"},{"location":"guides/concurrency-and-parallelism/#patterns","text":"","title":"Patterns"},{"location":"guides/concurrency-and-parallelism/#task-parallelism","text":"The go function can run different codes concurrently. For example, the following code runs the functions, computeA and computeB concurrently. Runtimes of applications might execute those functions even in parallel if their system packages allow that. compute = \\(x number, y number) number { z = go(\\() number { computeA(x) }) v = computeB(y) v + z }","title":"Task parallelism"},{"location":"guides/concurrency-and-parallelism/#data-parallelism","text":"To run the same computation against many values of the same type, you can use recursion and the go function. computeMany = \\(xs [number]) [number] { if [x, ...xs] = xs { y = go(\\() number { foo(x()) }) ys = computeMany(xs) [number y(), ...ys] } else { [number] } } The example above computes things in order of elements in the original list. However, you might want to see output values of concurrent computation in order of their finished times. By doing that, you can start using the output values as fast as possible without waiting for all computation to be completed. In this case, you can use the race function to reorder elements in the output list by their finished times. compute = \\(xs [number]) [number] { race([[number] [number x()] for x in computeMany(xs)]) } If you want to evaluate elements in multiple lists concurrently, you can simply pass the lists as an argument to the race function. Note that elements in the same lists are not evaluated concurrently although elements in different lists are evaluated concurrently. compute = \\(xs [number], ys [number]) [number] { race([[number] computeMany(xs), computeMany(ys)]) }","title":"Data parallelism"},{"location":"guides/creating-a-library/","text":"Creating a library This page describes how to create a library in Pen. It consists of the following steps: Create a library package. Publish the package. Creating a library package Library packages are packages imported and used by other packages. To create it, you run a pen create --library command with your library's name (e.g. foo ) in your terminal. pen create --library foo Then, you should see a foo directory in your current directory. When you go there, you should see a Foo.pen source file and a pen.json file for package configuration . Foo.pen : Add = \\(x number, y number) number { x + y } pen.json : { \"type\": \"library\", \"dependencies\": {} } In this example, the Foo.pen file contains an Add function that adds two numbers. And the pen.json configuration file defines a package type of library and its dependencies of none. Publishing a package The easiest way to publish your library package is to push the package as a Git repository onto one of Git repository hosting services, such as GitHub . git add . git commit git remote add origin ssh://git@github.com/your-name/foo git push Now, your package is ready for use by other packages! Next steps Building an executable Using a library Language syntax","title":"Creating a library"},{"location":"guides/creating-a-library/#creating-a-library","text":"This page describes how to create a library in Pen. It consists of the following steps: Create a library package. Publish the package.","title":"Creating a library"},{"location":"guides/creating-a-library/#creating-a-library-package","text":"Library packages are packages imported and used by other packages. To create it, you run a pen create --library command with your library's name (e.g. foo ) in your terminal. pen create --library foo Then, you should see a foo directory in your current directory. When you go there, you should see a Foo.pen source file and a pen.json file for package configuration . Foo.pen : Add = \\(x number, y number) number { x + y } pen.json : { \"type\": \"library\", \"dependencies\": {} } In this example, the Foo.pen file contains an Add function that adds two numbers. And the pen.json configuration file defines a package type of library and its dependencies of none.","title":"Creating a library package"},{"location":"guides/creating-a-library/#publishing-a-package","text":"The easiest way to publish your library package is to push the package as a Git repository onto one of Git repository hosting services, such as GitHub . git add . git commit git remote add origin ssh://git@github.com/your-name/foo git push Now, your package is ready for use by other packages!","title":"Publishing a package"},{"location":"guides/creating-a-library/#next-steps","text":"Building an executable Using a library Language syntax","title":"Next steps"},{"location":"guides/testing/","text":"Testing This page describes how to write and run unit tests for programs written in Pen. Testing codes consists of the following steps: Write tests as test functions in test modules. Run the tests with a pen test command. Writing tests You can write tests as test functions in test modules. All modules with the .test.pen file extension are test modules. And, all public functions in test modules are test functions. The test functions need to have a type of \\() none | error and should return error values when they fail. For example, to test a Foo function in a Foo.pen module, write a Foo.test.pen test module with the following contents. import Test'Assert import 'Foo CheckFoo = \\() none | error { Assert'Equal(Foo'Foo(), 42) } The Test package The Test standard package includes some utilities which helps you to write tests. Running tests To run tests, you can run a pen test command in your package's directory. Then, you should see test results of test functions in test modules. The pen test command exits with a non-zero status code if some tests fail.","title":"Testing"},{"location":"guides/testing/#testing","text":"This page describes how to write and run unit tests for programs written in Pen. Testing codes consists of the following steps: Write tests as test functions in test modules. Run the tests with a pen test command.","title":"Testing"},{"location":"guides/testing/#writing-tests","text":"You can write tests as test functions in test modules. All modules with the .test.pen file extension are test modules. And, all public functions in test modules are test functions. The test functions need to have a type of \\() none | error and should return error values when they fail. For example, to test a Foo function in a Foo.pen module, write a Foo.test.pen test module with the following contents. import Test'Assert import 'Foo CheckFoo = \\() none | error { Assert'Equal(Foo'Foo(), 42) }","title":"Writing tests"},{"location":"guides/testing/#the-test-package","text":"The Test standard package includes some utilities which helps you to write tests.","title":"The Test package"},{"location":"guides/testing/#running-tests","text":"To run tests, you can run a pen test command in your package's directory. Then, you should see test results of test functions in test modules. The pen test command exits with a non-zero status code if some tests fail.","title":"Running tests"},{"location":"guides/using-a-library/","text":"Using a library This page describes how to use a library in Pen. It consists of the following steps: Add a library package as a dependency in another package. Import functions and types from the library package. Modifying package configuration To use a library package, you need to add the package as a dependency in another package. To add the dependency, you modify a pen.json configuration file in the package adding the library package's name (e.g. Foo ) and URL (e.g. git://github.com/your-name/foo ) in a dependencies field like the following example. Note that you need to specify a git protocol scheme for library packages published as Git repositories. For other kinds of library packages, see Package configuration . { \"type\": \"application\", // This can be any type. \"dependencies\": { \"Foo\": \"git://github.com/your-name/foo\" } } Importing functions and types from a library package To import functions and types from the library package, you use import statements in a source file of your module with a name of the library package (e.g. Foo ) and a module name (e.g. Math ) where functions or types you want to use are defined. import Foo'Math Then, you are ready to use those functions and types with a prefix of the module name! For example, to call a function named Add in the Math module, you can write Math'Add(x, y) . type MyType = Math'Order MyFunction = \\(x number, y number) number { Math'Add(x, y) } Next steps Building an executable Creating a library Language syntax Import statement","title":"Using a library"},{"location":"guides/using-a-library/#using-a-library","text":"This page describes how to use a library in Pen. It consists of the following steps: Add a library package as a dependency in another package. Import functions and types from the library package.","title":"Using a library"},{"location":"guides/using-a-library/#modifying-package-configuration","text":"To use a library package, you need to add the package as a dependency in another package. To add the dependency, you modify a pen.json configuration file in the package adding the library package's name (e.g. Foo ) and URL (e.g. git://github.com/your-name/foo ) in a dependencies field like the following example. Note that you need to specify a git protocol scheme for library packages published as Git repositories. For other kinds of library packages, see Package configuration . { \"type\": \"application\", // This can be any type. \"dependencies\": { \"Foo\": \"git://github.com/your-name/foo\" } }","title":"Modifying package configuration"},{"location":"guides/using-a-library/#importing-functions-and-types-from-a-library-package","text":"To import functions and types from the library package, you use import statements in a source file of your module with a name of the library package (e.g. Foo ) and a module name (e.g. Math ) where functions or types you want to use are defined. import Foo'Math Then, you are ready to use those functions and types with a prefix of the module name! For example, to call a function named Add in the Math module, you can write Math'Add(x, y) . type MyType = Math'Order MyFunction = \\(x number, y number) number { Math'Add(x, y) }","title":"Importing functions and types from a library package"},{"location":"guides/using-a-library/#next-steps","text":"Building an executable Creating a library Language syntax Import statement","title":"Next steps"},{"location":"introduction/building-the-first-program/","text":"Building the first program Creating a package To create your first package, run a pen create command with your package's name in your terminal. pen create foo Then, you should see a directory named foo in your current directory. When you go into the directory, you should see a main.pen source file and a pen.json file for package configuration . Building a package To build the package, run a pen build command in the foo directory. pen build Then, you will see an executable file named app in the directory. Run it to see your first \"Hello, world!\" ./app # -> Hello, world! Now, you can start editing source files and build your own application in Pen! Next steps To use other library packages, see Using a library . For more code examples, see Examples . For the language syntax, see Syntax and Types . For usage of the standard packages, see Standard packages . To add more modules in your package, see Modules .","title":"Building the first program"},{"location":"introduction/building-the-first-program/#building-the-first-program","text":"","title":"Building the first program"},{"location":"introduction/building-the-first-program/#creating-a-package","text":"To create your first package, run a pen create command with your package's name in your terminal. pen create foo Then, you should see a directory named foo in your current directory. When you go into the directory, you should see a main.pen source file and a pen.json file for package configuration .","title":"Creating a package"},{"location":"introduction/building-the-first-program/#building-a-package","text":"To build the package, run a pen build command in the foo directory. pen build Then, you will see an executable file named app in the directory. Run it to see your first \"Hello, world!\" ./app # -> Hello, world! Now, you can start editing source files and build your own application in Pen!","title":"Building a package"},{"location":"introduction/building-the-first-program/#next-steps","text":"To use other library packages, see Using a library . For more code examples, see Examples . For the language syntax, see Syntax and Types . For usage of the standard packages, see Standard packages . To add more modules in your package, see Modules .","title":"Next steps"},{"location":"introduction/install/","text":"Install Via Homebrew On Linux, macOS and WSL , you can install Pen through Homebrew . Install Homebrew . Run the following command in your terminal. brew install pen-lang/pen/pen Now, you should be able to run a pen command in your shell. pen --version Building from source You can also build Pen from source on your local machine. Install the following software using a package manager of your choice (e.g. apt for Ubuntu and Homebrew for macOS.) Rust LLVM 14 Git Ninja Clone the Git repository. git clone https://github.com/pen-lang/pen Run a cargo command in the repository's directory. cargo install --path cmd/pen Set a PEN_ROOT environment variable to the directory. export PEN_ROOT=<directory> Now, you are ready to use the pen command built manually.","title":"Install"},{"location":"introduction/install/#install","text":"","title":"Install"},{"location":"introduction/install/#via-homebrew","text":"On Linux, macOS and WSL , you can install Pen through Homebrew . Install Homebrew . Run the following command in your terminal. brew install pen-lang/pen/pen Now, you should be able to run a pen command in your shell. pen --version","title":"Via Homebrew"},{"location":"introduction/install/#building-from-source","text":"You can also build Pen from source on your local machine. Install the following software using a package manager of your choice (e.g. apt for Ubuntu and Homebrew for macOS.) Rust LLVM 14 Git Ninja Clone the Git repository. git clone https://github.com/pen-lang/pen Run a cargo command in the repository's directory. cargo install --path cmd/pen Set a PEN_ROOT environment variable to the directory. export PEN_ROOT=<directory> Now, you are ready to use the pen command built manually.","title":"Building from source"},{"location":"references/command-line-tools/","text":"Command line tools The pen command has the following sub-commands. For more information, see its help message by running pen --help . build command It builds a package in the current directory. pen build create command It creates a package of a given kind in a specified directory. Creating an application package pen create foo Creating a library package pen create --library foo test command It runs test modules in a package. See also Testing . pen test format command It formats all module files in a package. pen format document command It generates a documentation file of a package and emits it to stdout. pen document \\ --name Foo \\ --description \"A package to provide Foo\" \\ --url git://github.com/foo/foo","title":"Command line tools"},{"location":"references/command-line-tools/#command-line-tools","text":"The pen command has the following sub-commands. For more information, see its help message by running pen --help .","title":"Command line tools"},{"location":"references/command-line-tools/#build-command","text":"It builds a package in the current directory. pen build","title":"build command"},{"location":"references/command-line-tools/#create-command","text":"It creates a package of a given kind in a specified directory.","title":"create command"},{"location":"references/command-line-tools/#creating-an-application-package","text":"pen create foo","title":"Creating an application package"},{"location":"references/command-line-tools/#creating-a-library-package","text":"pen create --library foo","title":"Creating a library package"},{"location":"references/command-line-tools/#test-command","text":"It runs test modules in a package. See also Testing . pen test","title":"test command"},{"location":"references/command-line-tools/#format-command","text":"It formats all module files in a package. pen format","title":"format command"},{"location":"references/command-line-tools/#document-command","text":"It generates a documentation file of a package and emits it to stdout. pen document \\ --name Foo \\ --description \"A package to provide Foo\" \\ --url git://github.com/foo/foo","title":"document command"},{"location":"references/language/built-ins/","text":"Built-ins Built-in types and functions are ones implicitly defined in every module. Types See Types . Functions size It calculates a size of a list or map. It is generic and you can apply it to any list and map types. Its time complexity is O(n) for lists and O(1) for maps. \\(list [a]) number \\(map {k: v}) number delete It deletes a key from a map. \\(map {k: v}, key k) {k: v} keys It gets keys in a map. \\(map {k: v}) [k] values It gets values in a map. \\(map {k: v}) [v] error It creates an error with its source information. \\(x any) error source It extracts source information from an error. \\(e error) any debug It pretty-prints a given value. Note that behavior of this function can change among system packages. You may not even see any messages with system packages whose systems do not have any consoles. \\(x any) none go It executes a function concurrently. Its return value is a future represented as a function that returns a result of the executed function. \\(\\() a) \\() a race It merges multiple lists into one by evaluating elements in the lists concurrently. Elements in each list are evaluated sequentially in order. This function corresponds to the fan-in concurrency pattern in other languages where results of concurrent computation in multiple queues are merged into a queue. \\([[a]]) [a]","title":"Built-ins"},{"location":"references/language/built-ins/#built-ins","text":"Built-in types and functions are ones implicitly defined in every module.","title":"Built-ins"},{"location":"references/language/built-ins/#types","text":"See Types .","title":"Types"},{"location":"references/language/built-ins/#functions","text":"","title":"Functions"},{"location":"references/language/built-ins/#size","text":"It calculates a size of a list or map. It is generic and you can apply it to any list and map types. Its time complexity is O(n) for lists and O(1) for maps. \\(list [a]) number \\(map {k: v}) number","title":"size"},{"location":"references/language/built-ins/#delete","text":"It deletes a key from a map. \\(map {k: v}, key k) {k: v}","title":"delete"},{"location":"references/language/built-ins/#keys","text":"It gets keys in a map. \\(map {k: v}) [k]","title":"keys"},{"location":"references/language/built-ins/#values","text":"It gets values in a map. \\(map {k: v}) [v]","title":"values"},{"location":"references/language/built-ins/#error","text":"It creates an error with its source information. \\(x any) error","title":"error"},{"location":"references/language/built-ins/#source","text":"It extracts source information from an error. \\(e error) any","title":"source"},{"location":"references/language/built-ins/#debug","text":"It pretty-prints a given value. Note that behavior of this function can change among system packages. You may not even see any messages with system packages whose systems do not have any consoles. \\(x any) none","title":"debug"},{"location":"references/language/built-ins/#go","text":"It executes a function concurrently. Its return value is a future represented as a function that returns a result of the executed function. \\(\\() a) \\() a","title":"go"},{"location":"references/language/built-ins/#race","text":"It merges multiple lists into one by evaluating elements in the lists concurrently. Elements in each list are evaluated sequentially in order. This function corresponds to the fan-in concurrency pattern in other languages where results of concurrent computation in multiple queues are merged into a queue. \\([[a]]) [a]","title":"race"},{"location":"references/language/modules/","text":"Modules Modules are sets of functions and types. Using modules, you can split large programs into smaller chunks. Each source file suffixed with a .pen file extension composes a module. Modules can import functions and types from other modules. Exporting functions and types from modules You can name functions and types in an upper camel case for them to be accessible from other modules. type Foo { ... } type Bar = ... Foo = \\() number { ... } Importing functions and types from modules In order to import functions and types from other modules, place import statements at the top of modules. The first components in the statements are names of external packages you declare in package configuration files ( Foo .) They are omitted if imported modules are in the same packages. The rest of the components are directory names where the modules exist ( Bar ) and the modules' filenames without their file extensions ( Baz for Baz.pen .) import Foo'Bar'Baz Then, you can access exported members of the modules with their prefixes. type foo = Baz'Type bar = \\(x number) number { Baz'Function(x) } Module names Modules in the same package Modules in the same package are referenced by their paths relative to a root directory of the package. For example, a module of a file at <package directory>/Foo/Bar.pen is imported as below. import 'Foo'Bar Modules in other packages Modules in other packages are referenced by their package names defined in package configuration files and module paths. For example, a module of a file at <package directory>/Bar/Baz.pen in a package Foo is imported as below. import Foo'Bar'Baz Private modules For modules to be private and not accessible from other packages, you can name them in lower camel case (e.g. fooBar .) Custom prefixes Imported modules can have custom prefixes given different names after the as keywords. import Foo'Bar'Baz as Blah Unqualified import You can import functions and types without prefixes by putting their names between { and } in import statements . This is especially useful when module names and imported functions or types have the same names like import 'MyType { MyType } . import Foo'Bar { Foo, Bar } type Baz { foo Foo } Blah = \\() number { Bar() }","title":"Modules"},{"location":"references/language/modules/#modules","text":"Modules are sets of functions and types. Using modules, you can split large programs into smaller chunks. Each source file suffixed with a .pen file extension composes a module. Modules can import functions and types from other modules.","title":"Modules"},{"location":"references/language/modules/#exporting-functions-and-types-from-modules","text":"You can name functions and types in an upper camel case for them to be accessible from other modules. type Foo { ... } type Bar = ... Foo = \\() number { ... }","title":"Exporting functions and types from modules"},{"location":"references/language/modules/#importing-functions-and-types-from-modules","text":"In order to import functions and types from other modules, place import statements at the top of modules. The first components in the statements are names of external packages you declare in package configuration files ( Foo .) They are omitted if imported modules are in the same packages. The rest of the components are directory names where the modules exist ( Bar ) and the modules' filenames without their file extensions ( Baz for Baz.pen .) import Foo'Bar'Baz Then, you can access exported members of the modules with their prefixes. type foo = Baz'Type bar = \\(x number) number { Baz'Function(x) }","title":"Importing functions and types from modules"},{"location":"references/language/modules/#module-names","text":"","title":"Module names"},{"location":"references/language/modules/#modules-in-the-same-package","text":"Modules in the same package are referenced by their paths relative to a root directory of the package. For example, a module of a file at <package directory>/Foo/Bar.pen is imported as below. import 'Foo'Bar","title":"Modules in the same package"},{"location":"references/language/modules/#modules-in-other-packages","text":"Modules in other packages are referenced by their package names defined in package configuration files and module paths. For example, a module of a file at <package directory>/Bar/Baz.pen in a package Foo is imported as below. import Foo'Bar'Baz","title":"Modules in other packages"},{"location":"references/language/modules/#private-modules","text":"For modules to be private and not accessible from other packages, you can name them in lower camel case (e.g. fooBar .)","title":"Private modules"},{"location":"references/language/modules/#custom-prefixes","text":"Imported modules can have custom prefixes given different names after the as keywords. import Foo'Bar'Baz as Blah","title":"Custom prefixes"},{"location":"references/language/modules/#unqualified-import","text":"You can import functions and types without prefixes by putting their names between { and } in import statements . This is especially useful when module names and imported functions or types have the same names like import 'MyType { MyType } . import Foo'Bar { Foo, Bar } type Baz { foo Foo } Blah = \\() number { Bar() }","title":"Unqualified import"},{"location":"references/language/packages/","text":"Packages Packages are sets of modules . Like modules, packages can import other packages specifying them in their configurations . What composes a package? The following entities compose packages. Standard packages bundled in installation of the language Remote repositories managed by version control systems (VCS) Currently, Pen supports only Git as a VCS. Directories with package configuration files on file systems During builds of packages, Pen's build system automatically download and initialize their dependency packages based on their URLs. Package types There are 3 package types: application, library, and system. Those types are specified in package configuration files . Application packages Application packages build applications often as executable files. Every application package must have a main.pen module file at its top directory. The main module has a main function that receives an argument of a context type and returns a none type. The context type is a record type containing context values of system packages with their field names of package names. For example, given system packages named Http and Os , a main function looks like the following. main = \\(ctx context) none { s = fetch(ctx.Http, \"https://pen-lang.org/\") print(ctx.Os, s) none } Every application package must specify one and only one system package that links applications (e.g. the Os standard system package) in its package configuration file . However, application packages can specify system packages that do not link applications (e.g. the Http system package in the example above) as many as possible. Library packages Library packages contain functions and types that have no side effects. They are imported and used by other packages. System packages System packages contain functions and types that have side effects to provide system interfaces to application packages. The language currently provides the two standard system packages of Os and OsSync . Although they can be imported by library packages as well as application packages, then they are expected not to cause any side effects. If you want to write your own system packages, see Writing system packages . Package configuration Each package has its configuration file named pen.json in a JSON format at its top directory. The JSON file has the following fields. Name Required Description type Yes Package type (either application , library , or system ) dependencies Yes Map of package names to their URLs Package URLs have different protocol schemes depending on where they are located. Standard packages: pen Git repositories: git Directories on file systems: none Examples Application { \"type\": \"application\", \"dependencies\": { \"Os\": \"pen:///os\", \"Core\": \"pen:///core\", \"Foo\": \"git://github.com/foo/foo\", \"Bar\": \"../bar\" } } Library { \"type\": \"library\", \"dependencies\": { \"Core\": \"pen:///core\", \"Foo\": \"git://github.com/foo/foo\", \"Bar\": \"../bar\" } } System { \"type\": \"system\", \"dependencies\": { \"Core\": \"pen:///core\", \"Foo\": \"git://github.com/foo/foo\", \"Bar\": \"../bar\" } }","title":"Packages"},{"location":"references/language/packages/#packages","text":"Packages are sets of modules . Like modules, packages can import other packages specifying them in their configurations .","title":"Packages"},{"location":"references/language/packages/#what-composes-a-package","text":"The following entities compose packages. Standard packages bundled in installation of the language Remote repositories managed by version control systems (VCS) Currently, Pen supports only Git as a VCS. Directories with package configuration files on file systems During builds of packages, Pen's build system automatically download and initialize their dependency packages based on their URLs.","title":"What composes a package?"},{"location":"references/language/packages/#package-types","text":"There are 3 package types: application, library, and system. Those types are specified in package configuration files .","title":"Package types"},{"location":"references/language/packages/#application-packages","text":"Application packages build applications often as executable files. Every application package must have a main.pen module file at its top directory. The main module has a main function that receives an argument of a context type and returns a none type. The context type is a record type containing context values of system packages with their field names of package names. For example, given system packages named Http and Os , a main function looks like the following. main = \\(ctx context) none { s = fetch(ctx.Http, \"https://pen-lang.org/\") print(ctx.Os, s) none } Every application package must specify one and only one system package that links applications (e.g. the Os standard system package) in its package configuration file . However, application packages can specify system packages that do not link applications (e.g. the Http system package in the example above) as many as possible.","title":"Application packages"},{"location":"references/language/packages/#library-packages","text":"Library packages contain functions and types that have no side effects. They are imported and used by other packages.","title":"Library packages"},{"location":"references/language/packages/#system-packages","text":"System packages contain functions and types that have side effects to provide system interfaces to application packages. The language currently provides the two standard system packages of Os and OsSync . Although they can be imported by library packages as well as application packages, then they are expected not to cause any side effects. If you want to write your own system packages, see Writing system packages .","title":"System packages"},{"location":"references/language/packages/#package-configuration","text":"Each package has its configuration file named pen.json in a JSON format at its top directory. The JSON file has the following fields. Name Required Description type Yes Package type (either application , library , or system ) dependencies Yes Map of package names to their URLs Package URLs have different protocol schemes depending on where they are located. Standard packages: pen Git repositories: git Directories on file systems: none","title":"Package configuration"},{"location":"references/language/packages/#examples","text":"","title":"Examples"},{"location":"references/language/packages/#application","text":"{ \"type\": \"application\", \"dependencies\": { \"Os\": \"pen:///os\", \"Core\": \"pen:///core\", \"Foo\": \"git://github.com/foo/foo\", \"Bar\": \"../bar\" } }","title":"Application"},{"location":"references/language/packages/#library","text":"{ \"type\": \"library\", \"dependencies\": { \"Core\": \"pen:///core\", \"Foo\": \"git://github.com/foo/foo\", \"Bar\": \"../bar\" } }","title":"Library"},{"location":"references/language/packages/#system","text":"{ \"type\": \"system\", \"dependencies\": { \"Core\": \"pen:///core\", \"Foo\": \"git://github.com/foo/foo\", \"Bar\": \"../bar\" } }","title":"System"},{"location":"references/language/syntax/","text":"Syntax This page describes syntax of Pen. You can compose programs building up those language constructs. See also Types about syntax for specific data types. Module Modules are sets of type and function definitions. Syntactically, a module consists of statements . See Modules about how modules themselves interact with each other. Statements Statements are constructs that declare functions and types in modules. Import statement It imports types and functions from another module from the same or another package. See Modules for more details. import Foo'Bar Foreign import statement It imports a function from a foreign language. See Foreign Function Interface (FFI) for more details. import foreign \"c\" foo \\(number, number) number Record type definition It defines a record type. See Records for more details. type foo { bar number baz string } Type alias It gives another name to a type. type foo = number | none Function definition It defines a function with a given name. The right-hand side of = signs must be function expressions . foo = \\(x number, y number) number { x + y } Foreign function definition It defines a function exported to foreign languages. See Foreign Function Interface (FFI) for more details. foreign \"c\" foo = \\(x number, y number) number { x + y } Block A block consists of 1 or more expressions wrapped in { and } . Values of the last expressions are treated as resulting values of the blocks. { foo(ctx, z) x + y + z } If you want to keep values of intermediate expressions for later use, you can define variables putting their names and = operators in front of the expressions. { x = 42 ... } Expressions Expressions represent some computation. Expressions can be nested; expressions often contain other expressions inside. Function call It calls a function to evaluate it with given arguments returning its result value. f(x, y) Operators Arithmetic Arithmetic operators add, subtract, multiply, or divide a number with another. 1 + 1 1 - 1 1 * 1 1 / 1 Comparison Equality Equal ( == ) and not-equal ( != ) operators compare two values and return a boolean value indicating if they are equal or not. 1 == 1 1 != 1 The operators can compare any types except functions and types containing them. \"foo\" == \"bar\" foo{x: 0} == foo{x: 1} 42 != none Ordering Order operators compare two numbers and return a boolean value indicating if the condition is correct or not. 1 < 1 1 <= 1 1 > 1 1 >= 1 Boolean A not operator flips a boolean value. !true An and operator returns true if both operands are true , or false otherwise. true & false An or operator returns true if either operand is true , or false otherwise. true | false Error handling ? suffix operators immediately exit the current functions with operands if they are of the error type . Both the operands and result values of functions where the operators are used must be a union type containing the error type . x? Function It creates a function. First, functions declare their argument names and types ( x number and y number ) and their result types ( number ). After that, function bodies of blocks describe how the functions compute result values. \\(x number, y number) number { x + y } Conditionals If expression It evaluates one of blocks depending on a condition of an expression of a boolean type. It evaluates the first block if a given boolean value is true . Otherwise, it evaluates the second block. if x { ... } else { ... } If-type expression It evaluates one of blocks depending on the type of a given expression. The expression ( foo() ) needs to be bound to a variable ( x ) and, in each block, the variable is treated as its specified type. if x = foo() as number { ... } else if string | none { ... } else { ... } If-list expression It deconstructs a list and evaluates one of two blocks depending on if the list is empty or not. If a given list has 1 or more element, it evaluates the first block with a function that returns its first element ( x ) and rest of elements as a list ( xs ). If the list has no element, it evaluates the second block. if [x, ...xs] = ... { ... } else { ... } If-map expression It gets a value for a key in a map and evaluates one of two blocks depending on if the map has the key or not. If a value for a key ( key ) is found, it evaluates the first block with the value ( value ). If the map has no such key, it evaluates the second block. if value = xs[key] { ... } else { ... } Loop List comprehension It iterates over elements in a given list and creates a new list with elements of a given expression. [number f(x()) for x in xs] You can iterate key-value pairs in a map. [number f(key, value) for key, value in map] You can use multiple for clauses to iterate multiple lists and maps. [number f(y()) for y in x() for x in xs ] You can use if clauses to filter elements. [number f(x()) for x in xs if g(x())] Comment Comments start with # and end with new-line characters. # This is a comment.","title":"Syntax"},{"location":"references/language/syntax/#syntax","text":"This page describes syntax of Pen. You can compose programs building up those language constructs. See also Types about syntax for specific data types.","title":"Syntax"},{"location":"references/language/syntax/#module","text":"Modules are sets of type and function definitions. Syntactically, a module consists of statements . See Modules about how modules themselves interact with each other.","title":"Module"},{"location":"references/language/syntax/#statements","text":"Statements are constructs that declare functions and types in modules.","title":"Statements"},{"location":"references/language/syntax/#import-statement","text":"It imports types and functions from another module from the same or another package. See Modules for more details. import Foo'Bar","title":"Import statement"},{"location":"references/language/syntax/#foreign-import-statement","text":"It imports a function from a foreign language. See Foreign Function Interface (FFI) for more details. import foreign \"c\" foo \\(number, number) number","title":"Foreign import statement"},{"location":"references/language/syntax/#record-type-definition","text":"It defines a record type. See Records for more details. type foo { bar number baz string }","title":"Record type definition"},{"location":"references/language/syntax/#type-alias","text":"It gives another name to a type. type foo = number | none","title":"Type alias"},{"location":"references/language/syntax/#function-definition","text":"It defines a function with a given name. The right-hand side of = signs must be function expressions . foo = \\(x number, y number) number { x + y }","title":"Function definition"},{"location":"references/language/syntax/#foreign-function-definition","text":"It defines a function exported to foreign languages. See Foreign Function Interface (FFI) for more details. foreign \"c\" foo = \\(x number, y number) number { x + y }","title":"Foreign function definition"},{"location":"references/language/syntax/#block","text":"A block consists of 1 or more expressions wrapped in { and } . Values of the last expressions are treated as resulting values of the blocks. { foo(ctx, z) x + y + z } If you want to keep values of intermediate expressions for later use, you can define variables putting their names and = operators in front of the expressions. { x = 42 ... }","title":"Block"},{"location":"references/language/syntax/#expressions","text":"Expressions represent some computation. Expressions can be nested; expressions often contain other expressions inside.","title":"Expressions"},{"location":"references/language/syntax/#function-call","text":"It calls a function to evaluate it with given arguments returning its result value. f(x, y)","title":"Function call"},{"location":"references/language/syntax/#operators","text":"","title":"Operators"},{"location":"references/language/syntax/#arithmetic","text":"Arithmetic operators add, subtract, multiply, or divide a number with another. 1 + 1 1 - 1 1 * 1 1 / 1","title":"Arithmetic"},{"location":"references/language/syntax/#comparison","text":"","title":"Comparison"},{"location":"references/language/syntax/#equality","text":"Equal ( == ) and not-equal ( != ) operators compare two values and return a boolean value indicating if they are equal or not. 1 == 1 1 != 1 The operators can compare any types except functions and types containing them. \"foo\" == \"bar\" foo{x: 0} == foo{x: 1} 42 != none","title":"Equality"},{"location":"references/language/syntax/#ordering","text":"Order operators compare two numbers and return a boolean value indicating if the condition is correct or not. 1 < 1 1 <= 1 1 > 1 1 >= 1","title":"Ordering"},{"location":"references/language/syntax/#boolean","text":"A not operator flips a boolean value. !true An and operator returns true if both operands are true , or false otherwise. true & false An or operator returns true if either operand is true , or false otherwise. true | false","title":"Boolean"},{"location":"references/language/syntax/#error-handling","text":"? suffix operators immediately exit the current functions with operands if they are of the error type . Both the operands and result values of functions where the operators are used must be a union type containing the error type . x?","title":"Error handling"},{"location":"references/language/syntax/#function","text":"It creates a function. First, functions declare their argument names and types ( x number and y number ) and their result types ( number ). After that, function bodies of blocks describe how the functions compute result values. \\(x number, y number) number { x + y }","title":"Function"},{"location":"references/language/syntax/#conditionals","text":"","title":"Conditionals"},{"location":"references/language/syntax/#if-expression","text":"It evaluates one of blocks depending on a condition of an expression of a boolean type. It evaluates the first block if a given boolean value is true . Otherwise, it evaluates the second block. if x { ... } else { ... }","title":"If expression"},{"location":"references/language/syntax/#if-type-expression","text":"It evaluates one of blocks depending on the type of a given expression. The expression ( foo() ) needs to be bound to a variable ( x ) and, in each block, the variable is treated as its specified type. if x = foo() as number { ... } else if string | none { ... } else { ... }","title":"If-type expression"},{"location":"references/language/syntax/#if-list-expression","text":"It deconstructs a list and evaluates one of two blocks depending on if the list is empty or not. If a given list has 1 or more element, it evaluates the first block with a function that returns its first element ( x ) and rest of elements as a list ( xs ). If the list has no element, it evaluates the second block. if [x, ...xs] = ... { ... } else { ... }","title":"If-list expression"},{"location":"references/language/syntax/#if-map-expression","text":"It gets a value for a key in a map and evaluates one of two blocks depending on if the map has the key or not. If a value for a key ( key ) is found, it evaluates the first block with the value ( value ). If the map has no such key, it evaluates the second block. if value = xs[key] { ... } else { ... }","title":"If-map expression"},{"location":"references/language/syntax/#loop","text":"","title":"Loop"},{"location":"references/language/syntax/#list-comprehension","text":"It iterates over elements in a given list and creates a new list with elements of a given expression. [number f(x()) for x in xs] You can iterate key-value pairs in a map. [number f(key, value) for key, value in map] You can use multiple for clauses to iterate multiple lists and maps. [number f(y()) for y in x() for x in xs ] You can use if clauses to filter elements. [number f(x()) for x in xs if g(x())]","title":"List comprehension"},{"location":"references/language/syntax/#comment","text":"Comments start with # and end with new-line characters. # This is a comment.","title":"Comment"},{"location":"references/language/types/","text":"Types This page describes different data types in Pen. Number It represents a real number. It is implemented as a 64-bit floating point number of IEEE 754 . number Literals 3.14 -42 Boolean It is a boolean value of true or false . boolean Literals true false None It represents a missing value. It has only a single value of none . none Literals none String It is a byte array. string Literals String literals are sequences of bytes. They are often used to represent texts encoded in UTF-8 . \"foo\" Escape sequences String literals can contain the following escape sequences. Escape sequence Name \\n New line \\r Carriage return \\t Tab \\\" Double quote \\\\ Backslash \\x9f Byte Functions A function represents reusable computation with arguments and a result. Functions represent not only pure computation but may also execute side effects, such as I/O. \\(number, number) number Literals \\(x number, y number) number { x + y } Lists It is a list of values. Its type contains an element type between [ and ] . [number] Literals A list literal contains its element type and elements as expressions. [number] [number 1] [number 1, 2, 3] You can create new lists from existing ones by spreading elements of the old ones prefixed by ... into the new ones. [number x, ...xs] Note that expressions within list literals are evaluated lazily ; they are evaluated only if their values are required. Maps It is a map from keys to values. Its type contains key and value types between { and } separated by : . {string: number} Literals A map literal contains its key and value types and key-value pairs as expressions. {string: number} {string: number \"foo\": 1} {string: number \"foo\": 1, \"bar\": 2} You can create new maps from existing ones by spreading entries of the old ones prefixed by ... into the new ones. {string: number ...map, \"foo\": 1} Records It combines multiple types into a single type. Each field of a record type is composed of its name and type. Fields are not accessible outside modules where they are defined by default. type person { name string age number } To expose fields as well as the type itself to other modules, you need to capitalize their names. type Person { Name string Age number } Literals Record values are constructed using record literals containing their field names and values separated by commas. person{name: \"foo\", age: 42} You can also create new records from existing ones spreading fields of the old ones into the new ones. person{...one, name: \"bar\"} You can access field values by appending their names with . prefixes to expressions of record types. john.name Unions It is a union of multiple types. For example, the type below represents values that can be either number or none . number | none Any Literally, it's an any type. Any values can be converted to the type. any Error It is an error. You can create error values by calling the error built-in function . See also Error handling . error","title":"Types"},{"location":"references/language/types/#types","text":"This page describes different data types in Pen.","title":"Types"},{"location":"references/language/types/#number","text":"It represents a real number. It is implemented as a 64-bit floating point number of IEEE 754 . number","title":"Number"},{"location":"references/language/types/#literals","text":"3.14 -42","title":"Literals"},{"location":"references/language/types/#boolean","text":"It is a boolean value of true or false . boolean","title":"Boolean"},{"location":"references/language/types/#literals_1","text":"true false","title":"Literals"},{"location":"references/language/types/#none","text":"It represents a missing value. It has only a single value of none . none","title":"None"},{"location":"references/language/types/#literals_2","text":"none","title":"Literals"},{"location":"references/language/types/#string","text":"It is a byte array. string","title":"String"},{"location":"references/language/types/#literals_3","text":"String literals are sequences of bytes. They are often used to represent texts encoded in UTF-8 . \"foo\"","title":"Literals"},{"location":"references/language/types/#escape-sequences","text":"String literals can contain the following escape sequences. Escape sequence Name \\n New line \\r Carriage return \\t Tab \\\" Double quote \\\\ Backslash \\x9f Byte","title":"Escape sequences"},{"location":"references/language/types/#functions","text":"A function represents reusable computation with arguments and a result. Functions represent not only pure computation but may also execute side effects, such as I/O. \\(number, number) number","title":"Functions"},{"location":"references/language/types/#literals_4","text":"\\(x number, y number) number { x + y }","title":"Literals"},{"location":"references/language/types/#lists","text":"It is a list of values. Its type contains an element type between [ and ] . [number]","title":"Lists"},{"location":"references/language/types/#literals_5","text":"A list literal contains its element type and elements as expressions. [number] [number 1] [number 1, 2, 3] You can create new lists from existing ones by spreading elements of the old ones prefixed by ... into the new ones. [number x, ...xs] Note that expressions within list literals are evaluated lazily ; they are evaluated only if their values are required.","title":"Literals"},{"location":"references/language/types/#maps","text":"It is a map from keys to values. Its type contains key and value types between { and } separated by : . {string: number}","title":"Maps"},{"location":"references/language/types/#literals_6","text":"A map literal contains its key and value types and key-value pairs as expressions. {string: number} {string: number \"foo\": 1} {string: number \"foo\": 1, \"bar\": 2} You can create new maps from existing ones by spreading entries of the old ones prefixed by ... into the new ones. {string: number ...map, \"foo\": 1}","title":"Literals"},{"location":"references/language/types/#records","text":"It combines multiple types into a single type. Each field of a record type is composed of its name and type. Fields are not accessible outside modules where they are defined by default. type person { name string age number } To expose fields as well as the type itself to other modules, you need to capitalize their names. type Person { Name string Age number }","title":"Records"},{"location":"references/language/types/#literals_7","text":"Record values are constructed using record literals containing their field names and values separated by commas. person{name: \"foo\", age: 42} You can also create new records from existing ones spreading fields of the old ones into the new ones. person{...one, name: \"bar\"} You can access field values by appending their names with . prefixes to expressions of record types. john.name","title":"Literals"},{"location":"references/language/types/#unions","text":"It is a union of multiple types. For example, the type below represents values that can be either number or none . number | none","title":"Unions"},{"location":"references/language/types/#any","text":"Literally, it's an any type. Any values can be converted to the type. any","title":"Any"},{"location":"references/language/types/#error","text":"It is an error. You can create error values by calling the error built-in function . See also Error handling . error","title":"Error"},{"location":"references/standard-packages/core/","text":"Core package This package provides common algorithms and data structures. { \"type\": \"library\" } Install { \"dependencies\": { \"Core\": \"pen:///core\" } } Core'Bit module This module provides bitwise operations. Most functions defined in this module take arguments of 64-bit integers. They can be converted from and into integers represented in IEEE-754 of a number type. Types No types are defined. Functions And Calculate bitwise \"and\" given two 64-bit integers. \\(x number, y number) number Or Calculate bitwise \"or\" given two 64-bit integers. \\(x number, y number) number Xor Calculate bitwise exclusive-\"or\" given two 64-bit integers. \\(x number, y number) number Not Calculate bitwise \"not\" given two 64-bit integers. \\(x number) number LeftShift Calculate unsigned left shift given a 64-bit integer. \\(x number, n number) number RightShift Calculate unsigned right shift given a 64-bit integer. \\(x number, n number) number ToInteger64 Convert an integer in IEEE-754 to a 64-bit integer. \\(x number) number FromInteger64 Convert a 64-bit integer to an integer in IEEE-754. \\(x number) number Core'Boolean module This module provides common boolean operations. Types No types are defined. Functions Any Return true if any of given booleans are true or false otherwise. \\(bs [boolean]) boolean All Return true if all of given booleans are true or false otherwise. \\(bs [boolean]) boolean Core'Character module Types No types are defined. Functions FromCodePoint \\(n number) string ToCodePoint \\(s string) number Core'List module This module provides common list operations. Types No types are defined. Functions First Get the first element in a list. If a list is empty, it returns a fallback value. \\(xs [any], fallback any) any Last Get the last element in a list. If a list is empty, it returns a fallback value. \\(xs [any], fallback any) any ToNumbers Convert a list of an any type to one of a number type skipping non- number types. \\(xs [any]) [number] ToStrings Convert a list of an any type to one of a string type skipping non- string types. \\(xs [any]) [string] ToBooleans Convert a list of an any type to one of a boolean type skipping non- boolean types. \\(xs [any]) [boolean] Core'Number module This module provides common number operations. Types No types are defined. Functions Absolute Calculate an absolute value. \\(x number) number Ceil Calculate a ceil value. \\(x number) number Epsilon Machine epsilon \\() number Exponential Calculate an exponential of a number. \\(x number) number Floor Calculate a floor value. \\(x number) number Fraction Calculate a fraction value of a number. \\(x number) number Infinity Infinity \\() number IsNan Check if a number is NaN. \\(x number) boolean Maximum Calculate a maximum. \\(x number, y number) number Minimum Calculate a minimum. \\(x number, y number) number Nan NaN \\() number Parse Parse a number. \\(s string) number | error Power Calculate a power. \\(base number, exponent number) number Range Create a list of numbers from a minimum to a maximum. \\(minimum number, maximum number) [number] Remainder Calculate a remainder. \\(dividend number, divisor number) number Round Round a number. \\(x number) number Sequence Create a list of numbers from 1 to a maximum value. \\(maximum number) [number] SquareRoot Calculate a square root. \\(x number) number String Convert a number into its string representation. \\(x number) string Sum Sum up numbers. \\(xs [number]) number Truncate Return an integer value of a number. \\(x number) number Core'String module This module provides common string operations. Types No types are defined. Functions Concatenate Concatenate strings. \\(strings [string]) string Join Join strings with a separator. \\(strings [string], separator string) string StartsWith Check if a string starts with a pattern. \\(s string, prefix string) boolean Core'String'Byte module This module provides operations for strings as byte arrays. Types No types are defined. Functions Length Return a length of a string. \\(s string) number Slice Slice a string. \\(s string, start number, end number) string Core'String'Byte'View module This module provides views of strings as byte arrays. By using those views, you can apply operations to strings without copying them. Types View A view of a string type View { # ... } Functions New Create a view of a string. \\(s string) View Viewee Get an original string. \\(v View) string Start Get a start index of a view. \\(v View) number End Get an end index of a view. \\(v View) number StartsWith Check if a string starts with a pattern. \\(v View, s string) boolean Length Get a length of a view. \\(v View) number Seek Move a start index forward. \\(v View, n number) View Slice Slice a view. \\(v View, start number, end number) View ToString Convert a view into a string. \\(v View) string Core'String'Utf8 module This module provides operations for strings encoded in UTF-8. Types No types are defined. Functions Characters Split a string into characters. \\(s string) [string] Contains Check if a string contains a pattern. \\(s string, pat string) boolean Find Find an index for a pattern in a string. \\(s string, pat string) number | none StartsWith Checks if a string starts with a pattern.. \\(s string, pat string) boolean EndsWith Checks if a string ends with a pattern.. \\(s string, pat string) boolean Length Return a length of a string. \\(s string) number Replace Replace a pattern in a string. \\(s string, pattern string, replacement string) string Slice Slice a string. \\(s string, start number, end number) string Split Split a string by a pattern. \\(s string, pat string) [string] ToLowercase Convert a string into lowercase. \\(s string) string ToUppercase Convert a string into uppercase. \\(s string) string Trim Trim leading and trailing spaces. \\(s string) string TrimEnd Trim trailing spaces. \\(s string) string TrimEndMatches Trim trailing patterns. \\(s string, pat string) string TrimMatches Trim leading and trailing patterns. \\(s string, pat string) string TrimStart Trim leading spaces. \\(s string) string TrimStartMatches Trim leading patterns. \\(s string, pat string) string","title":"Core"},{"location":"references/standard-packages/core/#core-package","text":"This package provides common algorithms and data structures. { \"type\": \"library\" }","title":"Core package"},{"location":"references/standard-packages/core/#install","text":"{ \"dependencies\": { \"Core\": \"pen:///core\" } }","title":"Install"},{"location":"references/standard-packages/core/#corebit-module","text":"This module provides bitwise operations. Most functions defined in this module take arguments of 64-bit integers. They can be converted from and into integers represented in IEEE-754 of a number type.","title":"Core'Bit module"},{"location":"references/standard-packages/core/#types","text":"No types are defined.","title":"Types"},{"location":"references/standard-packages/core/#functions","text":"","title":"Functions"},{"location":"references/standard-packages/core/#and","text":"Calculate bitwise \"and\" given two 64-bit integers. \\(x number, y number) number","title":"And"},{"location":"references/standard-packages/core/#or","text":"Calculate bitwise \"or\" given two 64-bit integers. \\(x number, y number) number","title":"Or"},{"location":"references/standard-packages/core/#xor","text":"Calculate bitwise exclusive-\"or\" given two 64-bit integers. \\(x number, y number) number","title":"Xor"},{"location":"references/standard-packages/core/#not","text":"Calculate bitwise \"not\" given two 64-bit integers. \\(x number) number","title":"Not"},{"location":"references/standard-packages/core/#leftshift","text":"Calculate unsigned left shift given a 64-bit integer. \\(x number, n number) number","title":"LeftShift"},{"location":"references/standard-packages/core/#rightshift","text":"Calculate unsigned right shift given a 64-bit integer. \\(x number, n number) number","title":"RightShift"},{"location":"references/standard-packages/core/#tointeger64","text":"Convert an integer in IEEE-754 to a 64-bit integer. \\(x number) number","title":"ToInteger64"},{"location":"references/standard-packages/core/#frominteger64","text":"Convert a 64-bit integer to an integer in IEEE-754. \\(x number) number","title":"FromInteger64"},{"location":"references/standard-packages/core/#coreboolean-module","text":"This module provides common boolean operations.","title":"Core'Boolean module"},{"location":"references/standard-packages/core/#types_1","text":"No types are defined.","title":"Types"},{"location":"references/standard-packages/core/#functions_1","text":"","title":"Functions"},{"location":"references/standard-packages/core/#any","text":"Return true if any of given booleans are true or false otherwise. \\(bs [boolean]) boolean","title":"Any"},{"location":"references/standard-packages/core/#all","text":"Return true if all of given booleans are true or false otherwise. \\(bs [boolean]) boolean","title":"All"},{"location":"references/standard-packages/core/#corecharacter-module","text":"","title":"Core'Character module"},{"location":"references/standard-packages/core/#types_2","text":"No types are defined.","title":"Types"},{"location":"references/standard-packages/core/#functions_2","text":"","title":"Functions"},{"location":"references/standard-packages/core/#fromcodepoint","text":"\\(n number) string","title":"FromCodePoint"},{"location":"references/standard-packages/core/#tocodepoint","text":"\\(s string) number","title":"ToCodePoint"},{"location":"references/standard-packages/core/#corelist-module","text":"This module provides common list operations.","title":"Core'List module"},{"location":"references/standard-packages/core/#types_3","text":"No types are defined.","title":"Types"},{"location":"references/standard-packages/core/#functions_3","text":"","title":"Functions"},{"location":"references/standard-packages/core/#first","text":"Get the first element in a list. If a list is empty, it returns a fallback value. \\(xs [any], fallback any) any","title":"First"},{"location":"references/standard-packages/core/#last","text":"Get the last element in a list. If a list is empty, it returns a fallback value. \\(xs [any], fallback any) any","title":"Last"},{"location":"references/standard-packages/core/#tonumbers","text":"Convert a list of an any type to one of a number type skipping non- number types. \\(xs [any]) [number]","title":"ToNumbers"},{"location":"references/standard-packages/core/#tostrings","text":"Convert a list of an any type to one of a string type skipping non- string types. \\(xs [any]) [string]","title":"ToStrings"},{"location":"references/standard-packages/core/#tobooleans","text":"Convert a list of an any type to one of a boolean type skipping non- boolean types. \\(xs [any]) [boolean]","title":"ToBooleans"},{"location":"references/standard-packages/core/#corenumber-module","text":"This module provides common number operations.","title":"Core'Number module"},{"location":"references/standard-packages/core/#types_4","text":"No types are defined.","title":"Types"},{"location":"references/standard-packages/core/#functions_4","text":"","title":"Functions"},{"location":"references/standard-packages/core/#absolute","text":"Calculate an absolute value. \\(x number) number","title":"Absolute"},{"location":"references/standard-packages/core/#ceil","text":"Calculate a ceil value. \\(x number) number","title":"Ceil"},{"location":"references/standard-packages/core/#epsilon","text":"Machine epsilon \\() number","title":"Epsilon"},{"location":"references/standard-packages/core/#exponential","text":"Calculate an exponential of a number. \\(x number) number","title":"Exponential"},{"location":"references/standard-packages/core/#floor","text":"Calculate a floor value. \\(x number) number","title":"Floor"},{"location":"references/standard-packages/core/#fraction","text":"Calculate a fraction value of a number. \\(x number) number","title":"Fraction"},{"location":"references/standard-packages/core/#infinity","text":"Infinity \\() number","title":"Infinity"},{"location":"references/standard-packages/core/#isnan","text":"Check if a number is NaN. \\(x number) boolean","title":"IsNan"},{"location":"references/standard-packages/core/#maximum","text":"Calculate a maximum. \\(x number, y number) number","title":"Maximum"},{"location":"references/standard-packages/core/#minimum","text":"Calculate a minimum. \\(x number, y number) number","title":"Minimum"},{"location":"references/standard-packages/core/#nan","text":"NaN \\() number","title":"Nan"},{"location":"references/standard-packages/core/#parse","text":"Parse a number. \\(s string) number | error","title":"Parse"},{"location":"references/standard-packages/core/#power","text":"Calculate a power. \\(base number, exponent number) number","title":"Power"},{"location":"references/standard-packages/core/#range","text":"Create a list of numbers from a minimum to a maximum. \\(minimum number, maximum number) [number]","title":"Range"},{"location":"references/standard-packages/core/#remainder","text":"Calculate a remainder. \\(dividend number, divisor number) number","title":"Remainder"},{"location":"references/standard-packages/core/#round","text":"Round a number. \\(x number) number","title":"Round"},{"location":"references/standard-packages/core/#sequence","text":"Create a list of numbers from 1 to a maximum value. \\(maximum number) [number]","title":"Sequence"},{"location":"references/standard-packages/core/#squareroot","text":"Calculate a square root. \\(x number) number","title":"SquareRoot"},{"location":"references/standard-packages/core/#string","text":"Convert a number into its string representation. \\(x number) string","title":"String"},{"location":"references/standard-packages/core/#sum","text":"Sum up numbers. \\(xs [number]) number","title":"Sum"},{"location":"references/standard-packages/core/#truncate","text":"Return an integer value of a number. \\(x number) number","title":"Truncate"},{"location":"references/standard-packages/core/#corestring-module","text":"This module provides common string operations.","title":"Core'String module"},{"location":"references/standard-packages/core/#types_5","text":"No types are defined.","title":"Types"},{"location":"references/standard-packages/core/#functions_5","text":"","title":"Functions"},{"location":"references/standard-packages/core/#concatenate","text":"Concatenate strings. \\(strings [string]) string","title":"Concatenate"},{"location":"references/standard-packages/core/#join","text":"Join strings with a separator. \\(strings [string], separator string) string","title":"Join"},{"location":"references/standard-packages/core/#startswith","text":"Check if a string starts with a pattern. \\(s string, prefix string) boolean","title":"StartsWith"},{"location":"references/standard-packages/core/#corestringbyte-module","text":"This module provides operations for strings as byte arrays.","title":"Core'String'Byte module"},{"location":"references/standard-packages/core/#types_6","text":"No types are defined.","title":"Types"},{"location":"references/standard-packages/core/#functions_6","text":"","title":"Functions"},{"location":"references/standard-packages/core/#length","text":"Return a length of a string. \\(s string) number","title":"Length"},{"location":"references/standard-packages/core/#slice","text":"Slice a string. \\(s string, start number, end number) string","title":"Slice"},{"location":"references/standard-packages/core/#corestringbyteview-module","text":"This module provides views of strings as byte arrays. By using those views, you can apply operations to strings without copying them.","title":"Core'String'Byte'View module"},{"location":"references/standard-packages/core/#types_7","text":"","title":"Types"},{"location":"references/standard-packages/core/#view","text":"A view of a string type View { # ... }","title":"View"},{"location":"references/standard-packages/core/#functions_7","text":"","title":"Functions"},{"location":"references/standard-packages/core/#new","text":"Create a view of a string. \\(s string) View","title":"New"},{"location":"references/standard-packages/core/#viewee","text":"Get an original string. \\(v View) string","title":"Viewee"},{"location":"references/standard-packages/core/#start","text":"Get a start index of a view. \\(v View) number","title":"Start"},{"location":"references/standard-packages/core/#end","text":"Get an end index of a view. \\(v View) number","title":"End"},{"location":"references/standard-packages/core/#startswith_1","text":"Check if a string starts with a pattern. \\(v View, s string) boolean","title":"StartsWith"},{"location":"references/standard-packages/core/#length_1","text":"Get a length of a view. \\(v View) number","title":"Length"},{"location":"references/standard-packages/core/#seek","text":"Move a start index forward. \\(v View, n number) View","title":"Seek"},{"location":"references/standard-packages/core/#slice_1","text":"Slice a view. \\(v View, start number, end number) View","title":"Slice"},{"location":"references/standard-packages/core/#tostring","text":"Convert a view into a string. \\(v View) string","title":"ToString"},{"location":"references/standard-packages/core/#corestringutf8-module","text":"This module provides operations for strings encoded in UTF-8.","title":"Core'String'Utf8 module"},{"location":"references/standard-packages/core/#types_8","text":"No types are defined.","title":"Types"},{"location":"references/standard-packages/core/#functions_8","text":"","title":"Functions"},{"location":"references/standard-packages/core/#characters","text":"Split a string into characters. \\(s string) [string]","title":"Characters"},{"location":"references/standard-packages/core/#contains","text":"Check if a string contains a pattern. \\(s string, pat string) boolean","title":"Contains"},{"location":"references/standard-packages/core/#find","text":"Find an index for a pattern in a string. \\(s string, pat string) number | none","title":"Find"},{"location":"references/standard-packages/core/#startswith_2","text":"Checks if a string starts with a pattern.. \\(s string, pat string) boolean","title":"StartsWith"},{"location":"references/standard-packages/core/#endswith","text":"Checks if a string ends with a pattern.. \\(s string, pat string) boolean","title":"EndsWith"},{"location":"references/standard-packages/core/#length_2","text":"Return a length of a string. \\(s string) number","title":"Length"},{"location":"references/standard-packages/core/#replace","text":"Replace a pattern in a string. \\(s string, pattern string, replacement string) string","title":"Replace"},{"location":"references/standard-packages/core/#slice_2","text":"Slice a string. \\(s string, start number, end number) string","title":"Slice"},{"location":"references/standard-packages/core/#split","text":"Split a string by a pattern. \\(s string, pat string) [string]","title":"Split"},{"location":"references/standard-packages/core/#tolowercase","text":"Convert a string into lowercase. \\(s string) string","title":"ToLowercase"},{"location":"references/standard-packages/core/#touppercase","text":"Convert a string into uppercase. \\(s string) string","title":"ToUppercase"},{"location":"references/standard-packages/core/#trim","text":"Trim leading and trailing spaces. \\(s string) string","title":"Trim"},{"location":"references/standard-packages/core/#trimend","text":"Trim trailing spaces. \\(s string) string","title":"TrimEnd"},{"location":"references/standard-packages/core/#trimendmatches","text":"Trim trailing patterns. \\(s string, pat string) string","title":"TrimEndMatches"},{"location":"references/standard-packages/core/#trimmatches","text":"Trim leading and trailing patterns. \\(s string, pat string) string","title":"TrimMatches"},{"location":"references/standard-packages/core/#trimstart","text":"Trim leading spaces. \\(s string) string","title":"TrimStart"},{"location":"references/standard-packages/core/#trimstartmatches","text":"Trim leading patterns. \\(s string, pat string) string","title":"TrimStartMatches"},{"location":"references/standard-packages/flag/","text":"Flag package This package provides command-line flag parsing. { \"type\": \"library\" } Install { \"dependencies\": { \"Flag\": \"pen:///flag\" } } Flag'Flag module This module provides command-line flag parsing. The flags have the following formats: -foo bar : a named flag of a key foo with a value bar foo : a positional flag of a value foo Named flags and positional flags are separated by -- optionally. Types Set A set of flags type Set { Named {string: string} Positional [string] } Functions Parse Parse flags. \\(ss [string]) Set | error","title":"Flag"},{"location":"references/standard-packages/flag/#flag-package","text":"This package provides command-line flag parsing. { \"type\": \"library\" }","title":"Flag package"},{"location":"references/standard-packages/flag/#install","text":"{ \"dependencies\": { \"Flag\": \"pen:///flag\" } }","title":"Install"},{"location":"references/standard-packages/flag/#flagflag-module","text":"This module provides command-line flag parsing. The flags have the following formats: -foo bar : a named flag of a key foo with a value bar foo : a positional flag of a value foo Named flags and positional flags are separated by -- optionally.","title":"Flag'Flag module"},{"location":"references/standard-packages/flag/#types","text":"","title":"Types"},{"location":"references/standard-packages/flag/#set","text":"A set of flags type Set { Named {string: string} Positional [string] }","title":"Set"},{"location":"references/standard-packages/flag/#functions","text":"","title":"Functions"},{"location":"references/standard-packages/flag/#parse","text":"Parse flags. \\(ss [string]) Set | error","title":"Parse"},{"location":"references/standard-packages/html/","text":"Html package This package provides HTML rendering logic. { \"type\": \"library\" } Install { \"dependencies\": { \"Html\": \"pen:///html\" } } Html'Node module Types Node An HTML node type Node = Element | string Element An HTML element type Element { Tag string Attributes [Attribute] Children [Node] } Attribute An HTML attribute type Attribute { Key string Value string } Functions No functions are defined. Html'Render module Types No types are defined. Functions Render Render an HTML node. \\(n Node) string | error","title":"Html"},{"location":"references/standard-packages/html/#html-package","text":"This package provides HTML rendering logic. { \"type\": \"library\" }","title":"Html package"},{"location":"references/standard-packages/html/#install","text":"{ \"dependencies\": { \"Html\": \"pen:///html\" } }","title":"Install"},{"location":"references/standard-packages/html/#htmlnode-module","text":"","title":"Html'Node module"},{"location":"references/standard-packages/html/#types","text":"","title":"Types"},{"location":"references/standard-packages/html/#node","text":"An HTML node type Node = Element | string","title":"Node"},{"location":"references/standard-packages/html/#element","text":"An HTML element type Element { Tag string Attributes [Attribute] Children [Node] }","title":"Element"},{"location":"references/standard-packages/html/#attribute","text":"An HTML attribute type Attribute { Key string Value string }","title":"Attribute"},{"location":"references/standard-packages/html/#functions","text":"No functions are defined.","title":"Functions"},{"location":"references/standard-packages/html/#htmlrender-module","text":"","title":"Html'Render module"},{"location":"references/standard-packages/html/#types_1","text":"No types are defined.","title":"Types"},{"location":"references/standard-packages/html/#functions_1","text":"","title":"Functions"},{"location":"references/standard-packages/html/#render","text":"Render an HTML node. \\(n Node) string | error","title":"Render"},{"location":"references/standard-packages/http/","text":"Http package This package provides HTTP client and server. { \"type\": \"system\" } Install { \"dependencies\": { \"Http\": \"pen:///http\" } } Http'Client module This module provides an HTTP client. Types No types are defined. Functions Send Send an HTTP request. \\(ctx Context, r Request) Response | error Http'Context module Types Context An HTTP context type Context = context'Context Functions No functions are defined. Http'Request module Types Request An HTTP request type Request { Method string Uri string Headers {string: string} Body string } Functions No functions are defined. Http'Response module Types Response An HTTP response type Response { Status number Headers {string: string} Body string } Functions No functions are defined. Http'Server module This module provides an HTTP server. Types No types are defined. Functions Serve Run an HTTP service. \\(ctx Context, address string, callback \\(Request) Response) none | error","title":"Http"},{"location":"references/standard-packages/http/#http-package","text":"This package provides HTTP client and server. { \"type\": \"system\" }","title":"Http package"},{"location":"references/standard-packages/http/#install","text":"{ \"dependencies\": { \"Http\": \"pen:///http\" } }","title":"Install"},{"location":"references/standard-packages/http/#httpclient-module","text":"This module provides an HTTP client.","title":"Http'Client module"},{"location":"references/standard-packages/http/#types","text":"No types are defined.","title":"Types"},{"location":"references/standard-packages/http/#functions","text":"","title":"Functions"},{"location":"references/standard-packages/http/#send","text":"Send an HTTP request. \\(ctx Context, r Request) Response | error","title":"Send"},{"location":"references/standard-packages/http/#httpcontext-module","text":"","title":"Http'Context module"},{"location":"references/standard-packages/http/#types_1","text":"","title":"Types"},{"location":"references/standard-packages/http/#context","text":"An HTTP context type Context = context'Context","title":"Context"},{"location":"references/standard-packages/http/#functions_1","text":"No functions are defined.","title":"Functions"},{"location":"references/standard-packages/http/#httprequest-module","text":"","title":"Http'Request module"},{"location":"references/standard-packages/http/#types_2","text":"","title":"Types"},{"location":"references/standard-packages/http/#request","text":"An HTTP request type Request { Method string Uri string Headers {string: string} Body string }","title":"Request"},{"location":"references/standard-packages/http/#functions_2","text":"No functions are defined.","title":"Functions"},{"location":"references/standard-packages/http/#httpresponse-module","text":"","title":"Http'Response module"},{"location":"references/standard-packages/http/#types_3","text":"","title":"Types"},{"location":"references/standard-packages/http/#response","text":"An HTTP response type Response { Status number Headers {string: string} Body string }","title":"Response"},{"location":"references/standard-packages/http/#functions_3","text":"No functions are defined.","title":"Functions"},{"location":"references/standard-packages/http/#httpserver-module","text":"This module provides an HTTP server.","title":"Http'Server module"},{"location":"references/standard-packages/http/#types_4","text":"No types are defined.","title":"Types"},{"location":"references/standard-packages/http/#functions_4","text":"","title":"Functions"},{"location":"references/standard-packages/http/#serve","text":"Run an HTTP service. \\(ctx Context, address string, callback \\(Request) Response) none | error","title":"Serve"},{"location":"references/standard-packages/json/","text":"Json package This package provides a JSON parser. { \"type\": \"library\" } Install { \"dependencies\": { \"Json\": \"pen:///json\" } } Json'Decode module Types No types are defined. Functions Decode Decode a string into a JSON value. \\(s string) Value | error Json'Encode module Types No types are defined. Functions Encode Encode a JSON value. \\(v Value) string Json'Value module Types Value A JSON value type Value { # ... } Raw A raw JSON value represented by built-in types type Raw = boolean | none | number | string | [Value] | {string: Value} Functions New Create a JSON value. \\(r Raw) Value Raw Get a raw value. \\(v Value) Raw","title":"Json"},{"location":"references/standard-packages/json/#json-package","text":"This package provides a JSON parser. { \"type\": \"library\" }","title":"Json package"},{"location":"references/standard-packages/json/#install","text":"{ \"dependencies\": { \"Json\": \"pen:///json\" } }","title":"Install"},{"location":"references/standard-packages/json/#jsondecode-module","text":"","title":"Json'Decode module"},{"location":"references/standard-packages/json/#types","text":"No types are defined.","title":"Types"},{"location":"references/standard-packages/json/#functions","text":"","title":"Functions"},{"location":"references/standard-packages/json/#decode","text":"Decode a string into a JSON value. \\(s string) Value | error","title":"Decode"},{"location":"references/standard-packages/json/#jsonencode-module","text":"","title":"Json'Encode module"},{"location":"references/standard-packages/json/#types_1","text":"No types are defined.","title":"Types"},{"location":"references/standard-packages/json/#functions_1","text":"","title":"Functions"},{"location":"references/standard-packages/json/#encode","text":"Encode a JSON value. \\(v Value) string","title":"Encode"},{"location":"references/standard-packages/json/#jsonvalue-module","text":"","title":"Json'Value module"},{"location":"references/standard-packages/json/#types_2","text":"","title":"Types"},{"location":"references/standard-packages/json/#value","text":"A JSON value type Value { # ... }","title":"Value"},{"location":"references/standard-packages/json/#raw","text":"A raw JSON value represented by built-in types type Raw = boolean | none | number | string | [Value] | {string: Value}","title":"Raw"},{"location":"references/standard-packages/json/#functions_2","text":"","title":"Functions"},{"location":"references/standard-packages/json/#new","text":"Create a JSON value. \\(r Raw) Value","title":"New"},{"location":"references/standard-packages/json/#raw_1","text":"Get a raw value. \\(v Value) Raw","title":"Raw"},{"location":"references/standard-packages/os/","text":"Os package This package provides an interface for operating systems. { \"type\": \"system\" } Install { \"dependencies\": { \"Os\": \"pen:///os\" } } Os'Context module Types Context A context of an operating system. type Context = context'Context Functions No functions are defined. Os'Directory module Types No types are defined. Functions Read Read a directory and return file paths it contains. \\(ctx Context, path string) [string] | error Create Create a directory. \\(ctx Context, path string) none | error Remove Remove a directory. \\(ctx Context, path string) none | error Os'Environment module Types No types are defined. Functions Arguments Get command line arguments. \\(ctx Context) [string] Variable Get an environment variable. \\(ctx Context, name string) string | error Os'File module Types File A file on a file system. type File { # ... } Functions StdIn A file of standard input. \\() File StdOut A file of standard output. \\() File StdErr A file of standard error. \\() File Open Open a file for read-only. \\(ctx Context, path string) File | error OpenWithOptions Open a file with options. \\(ctx Context, path string, opt OpenOptions) File | error Read Read a file. \\(ctx Context, file File) string | error ReadLimit Read a file until a size limit. \\(ctx Context, file File, limit number) string | error Write Write data to a file. \\(ctx Context, file File, data string) number | error Copy Copy a file to another path. \\(ctx Context, src string, dest string) none | error Move Move a file to another path. \\(ctx Context, src string, dest string) none | error Remove Remove a file. \\(ctx Context, path string) none | error Metadata Get metadata of a file at a path. \\(ctx Context, path string) Metadata | error Os'File'Metadata module Types Metadata File metadata type Metadata { Size number } Functions No functions are defined. Os'File'OpenOptions module Types OpenOptions Options to open a file Append allows appending data to the file. Create creates a new file if the file doesn't exist or opens it otherwise. CreateNew creates a new file. If the file already exists, it emits an error. Read allows reading data from the file. Truncate truncates the file to zero byte. Write allows writing data to the file. type OpenOptions { Append boolean Create boolean CreateNew boolean Read boolean Truncate boolean Write boolean } Functions Default Get default options to open a file. They do not include any permission. \\() OpenOptions Os'Process module Types No types are defined. Functions Exit Exit a current process. \\(ctx Context, code number) none Run Run a command. \\(ctx Context, cmd string, args [string]) none | error Os'Tcp module Types No types are defined. Functions Bind Create a listener bound to a server address. \\(ctx Context, address string) Listener | error Connect Create a stream connected to a peer address. \\(ctx Context, address string) Stream | error Accept Accept a client connection and create its stream. \\(ctx Context, l Listener) AcceptedStream | error Receive Receive data from a peer through a stream with a size limit in bytes. \\(ctx Context, s Stream, limit number) string | error Send Send data to a peer through a stream. \\(ctx Context, s Stream, data string) number | error Os'Tcp'AcceptedStream module Types AcceptedStream A TCP stream accepted on a server with a client address type AcceptedStream { Stream Stream Address string } Functions No functions are defined. Os'Tcp'Listener module Types Listener A TCP listener to listen for client connections type Listener { # ... } Functions No functions are defined. Os'Tcp'Stream module Types Stream A TCP stream type Stream { # ... } Functions No functions are defined. Os'Time module Types No types are defined. Functions Now Fetch a current system time in milliseconds. \\(ctx Context) number Sleep Pause a current execution context for a given amount of time. \\(ctx Context, milliseconds number) none Os'Udp module Types No types are defined. Functions Bind Bind a socket with a server address. \\(ctx Context, address string) Socket | error Connect Connect a socket to a peer address. \\(ctx Context, s Socket, address string) none | error Receive Receive a datagram from a connected address. \\(ctx Context, s Socket) string | error ReceiveFrom Receive a datagram from any address. \\(ctx Context, s Socket) Datagram | error Send Send a datagram to a connected address. \\(ctx Context, s Socket, data string) number | error SendTo Send a datagram to a specified address. \\(ctx Context, s Socket, data string, address string) number | error Os'Udp'Datagram module Types Datagram UDP datagram type Datagram { Data string Address string } Functions No functions are defined. Os'Udp'Socket module Types Socket UDP socket type Socket { # ... } Functions No functions are defined.","title":"Os"},{"location":"references/standard-packages/os/#os-package","text":"This package provides an interface for operating systems. { \"type\": \"system\" }","title":"Os package"},{"location":"references/standard-packages/os/#install","text":"{ \"dependencies\": { \"Os\": \"pen:///os\" } }","title":"Install"},{"location":"references/standard-packages/os/#oscontext-module","text":"","title":"Os'Context module"},{"location":"references/standard-packages/os/#types","text":"","title":"Types"},{"location":"references/standard-packages/os/#context","text":"A context of an operating system. type Context = context'Context","title":"Context"},{"location":"references/standard-packages/os/#functions","text":"No functions are defined.","title":"Functions"},{"location":"references/standard-packages/os/#osdirectory-module","text":"","title":"Os'Directory module"},{"location":"references/standard-packages/os/#types_1","text":"No types are defined.","title":"Types"},{"location":"references/standard-packages/os/#functions_1","text":"","title":"Functions"},{"location":"references/standard-packages/os/#read","text":"Read a directory and return file paths it contains. \\(ctx Context, path string) [string] | error","title":"Read"},{"location":"references/standard-packages/os/#create","text":"Create a directory. \\(ctx Context, path string) none | error","title":"Create"},{"location":"references/standard-packages/os/#remove","text":"Remove a directory. \\(ctx Context, path string) none | error","title":"Remove"},{"location":"references/standard-packages/os/#osenvironment-module","text":"","title":"Os'Environment module"},{"location":"references/standard-packages/os/#types_2","text":"No types are defined.","title":"Types"},{"location":"references/standard-packages/os/#functions_2","text":"","title":"Functions"},{"location":"references/standard-packages/os/#arguments","text":"Get command line arguments. \\(ctx Context) [string]","title":"Arguments"},{"location":"references/standard-packages/os/#variable","text":"Get an environment variable. \\(ctx Context, name string) string | error","title":"Variable"},{"location":"references/standard-packages/os/#osfile-module","text":"","title":"Os'File module"},{"location":"references/standard-packages/os/#types_3","text":"","title":"Types"},{"location":"references/standard-packages/os/#file","text":"A file on a file system. type File { # ... }","title":"File"},{"location":"references/standard-packages/os/#functions_3","text":"","title":"Functions"},{"location":"references/standard-packages/os/#stdin","text":"A file of standard input. \\() File","title":"StdIn"},{"location":"references/standard-packages/os/#stdout","text":"A file of standard output. \\() File","title":"StdOut"},{"location":"references/standard-packages/os/#stderr","text":"A file of standard error. \\() File","title":"StdErr"},{"location":"references/standard-packages/os/#open","text":"Open a file for read-only. \\(ctx Context, path string) File | error","title":"Open"},{"location":"references/standard-packages/os/#openwithoptions","text":"Open a file with options. \\(ctx Context, path string, opt OpenOptions) File | error","title":"OpenWithOptions"},{"location":"references/standard-packages/os/#read_1","text":"Read a file. \\(ctx Context, file File) string | error","title":"Read"},{"location":"references/standard-packages/os/#readlimit","text":"Read a file until a size limit. \\(ctx Context, file File, limit number) string | error","title":"ReadLimit"},{"location":"references/standard-packages/os/#write","text":"Write data to a file. \\(ctx Context, file File, data string) number | error","title":"Write"},{"location":"references/standard-packages/os/#copy","text":"Copy a file to another path. \\(ctx Context, src string, dest string) none | error","title":"Copy"},{"location":"references/standard-packages/os/#move","text":"Move a file to another path. \\(ctx Context, src string, dest string) none | error","title":"Move"},{"location":"references/standard-packages/os/#remove_1","text":"Remove a file. \\(ctx Context, path string) none | error","title":"Remove"},{"location":"references/standard-packages/os/#metadata","text":"Get metadata of a file at a path. \\(ctx Context, path string) Metadata | error","title":"Metadata"},{"location":"references/standard-packages/os/#osfilemetadata-module","text":"","title":"Os'File'Metadata module"},{"location":"references/standard-packages/os/#types_4","text":"","title":"Types"},{"location":"references/standard-packages/os/#metadata_1","text":"File metadata type Metadata { Size number }","title":"Metadata"},{"location":"references/standard-packages/os/#functions_4","text":"No functions are defined.","title":"Functions"},{"location":"references/standard-packages/os/#osfileopenoptions-module","text":"","title":"Os'File'OpenOptions module"},{"location":"references/standard-packages/os/#types_5","text":"","title":"Types"},{"location":"references/standard-packages/os/#openoptions","text":"Options to open a file Append allows appending data to the file. Create creates a new file if the file doesn't exist or opens it otherwise. CreateNew creates a new file. If the file already exists, it emits an error. Read allows reading data from the file. Truncate truncates the file to zero byte. Write allows writing data to the file. type OpenOptions { Append boolean Create boolean CreateNew boolean Read boolean Truncate boolean Write boolean }","title":"OpenOptions"},{"location":"references/standard-packages/os/#functions_5","text":"","title":"Functions"},{"location":"references/standard-packages/os/#default","text":"Get default options to open a file. They do not include any permission. \\() OpenOptions","title":"Default"},{"location":"references/standard-packages/os/#osprocess-module","text":"","title":"Os'Process module"},{"location":"references/standard-packages/os/#types_6","text":"No types are defined.","title":"Types"},{"location":"references/standard-packages/os/#functions_6","text":"","title":"Functions"},{"location":"references/standard-packages/os/#exit","text":"Exit a current process. \\(ctx Context, code number) none","title":"Exit"},{"location":"references/standard-packages/os/#run","text":"Run a command. \\(ctx Context, cmd string, args [string]) none | error","title":"Run"},{"location":"references/standard-packages/os/#ostcp-module","text":"","title":"Os'Tcp module"},{"location":"references/standard-packages/os/#types_7","text":"No types are defined.","title":"Types"},{"location":"references/standard-packages/os/#functions_7","text":"","title":"Functions"},{"location":"references/standard-packages/os/#bind","text":"Create a listener bound to a server address. \\(ctx Context, address string) Listener | error","title":"Bind"},{"location":"references/standard-packages/os/#connect","text":"Create a stream connected to a peer address. \\(ctx Context, address string) Stream | error","title":"Connect"},{"location":"references/standard-packages/os/#accept","text":"Accept a client connection and create its stream. \\(ctx Context, l Listener) AcceptedStream | error","title":"Accept"},{"location":"references/standard-packages/os/#receive","text":"Receive data from a peer through a stream with a size limit in bytes. \\(ctx Context, s Stream, limit number) string | error","title":"Receive"},{"location":"references/standard-packages/os/#send","text":"Send data to a peer through a stream. \\(ctx Context, s Stream, data string) number | error","title":"Send"},{"location":"references/standard-packages/os/#ostcpacceptedstream-module","text":"","title":"Os'Tcp'AcceptedStream module"},{"location":"references/standard-packages/os/#types_8","text":"","title":"Types"},{"location":"references/standard-packages/os/#acceptedstream","text":"A TCP stream accepted on a server with a client address type AcceptedStream { Stream Stream Address string }","title":"AcceptedStream"},{"location":"references/standard-packages/os/#functions_8","text":"No functions are defined.","title":"Functions"},{"location":"references/standard-packages/os/#ostcplistener-module","text":"","title":"Os'Tcp'Listener module"},{"location":"references/standard-packages/os/#types_9","text":"","title":"Types"},{"location":"references/standard-packages/os/#listener","text":"A TCP listener to listen for client connections type Listener { # ... }","title":"Listener"},{"location":"references/standard-packages/os/#functions_9","text":"No functions are defined.","title":"Functions"},{"location":"references/standard-packages/os/#ostcpstream-module","text":"","title":"Os'Tcp'Stream module"},{"location":"references/standard-packages/os/#types_10","text":"","title":"Types"},{"location":"references/standard-packages/os/#stream","text":"A TCP stream type Stream { # ... }","title":"Stream"},{"location":"references/standard-packages/os/#functions_10","text":"No functions are defined.","title":"Functions"},{"location":"references/standard-packages/os/#ostime-module","text":"","title":"Os'Time module"},{"location":"references/standard-packages/os/#types_11","text":"No types are defined.","title":"Types"},{"location":"references/standard-packages/os/#functions_11","text":"","title":"Functions"},{"location":"references/standard-packages/os/#now","text":"Fetch a current system time in milliseconds. \\(ctx Context) number","title":"Now"},{"location":"references/standard-packages/os/#sleep","text":"Pause a current execution context for a given amount of time. \\(ctx Context, milliseconds number) none","title":"Sleep"},{"location":"references/standard-packages/os/#osudp-module","text":"","title":"Os'Udp module"},{"location":"references/standard-packages/os/#types_12","text":"No types are defined.","title":"Types"},{"location":"references/standard-packages/os/#functions_12","text":"","title":"Functions"},{"location":"references/standard-packages/os/#bind_1","text":"Bind a socket with a server address. \\(ctx Context, address string) Socket | error","title":"Bind"},{"location":"references/standard-packages/os/#connect_1","text":"Connect a socket to a peer address. \\(ctx Context, s Socket, address string) none | error","title":"Connect"},{"location":"references/standard-packages/os/#receive_1","text":"Receive a datagram from a connected address. \\(ctx Context, s Socket) string | error","title":"Receive"},{"location":"references/standard-packages/os/#receivefrom","text":"Receive a datagram from any address. \\(ctx Context, s Socket) Datagram | error","title":"ReceiveFrom"},{"location":"references/standard-packages/os/#send_1","text":"Send a datagram to a connected address. \\(ctx Context, s Socket, data string) number | error","title":"Send"},{"location":"references/standard-packages/os/#sendto","text":"Send a datagram to a specified address. \\(ctx Context, s Socket, data string, address string) number | error","title":"SendTo"},{"location":"references/standard-packages/os/#osudpdatagram-module","text":"","title":"Os'Udp'Datagram module"},{"location":"references/standard-packages/os/#types_13","text":"","title":"Types"},{"location":"references/standard-packages/os/#datagram","text":"UDP datagram type Datagram { Data string Address string }","title":"Datagram"},{"location":"references/standard-packages/os/#functions_13","text":"No functions are defined.","title":"Functions"},{"location":"references/standard-packages/os/#osudpsocket-module","text":"","title":"Os'Udp'Socket module"},{"location":"references/standard-packages/os/#types_14","text":"","title":"Types"},{"location":"references/standard-packages/os/#socket","text":"UDP socket type Socket { # ... }","title":"Socket"},{"location":"references/standard-packages/os/#functions_14","text":"No functions are defined.","title":"Functions"},{"location":"references/standard-packages/random/","text":"Random package This package provides random number generation. { \"type\": \"system\" } Install { \"dependencies\": { \"Random\": \"pen:///random\" } } Random'Context module Types Context A context of random number generation. type Context = context'Context Functions No functions are defined. Random'Random module Types No types are defined. Functions Number Generate a random number in a range of [0, 1). \\(ctx Context) number","title":"Random"},{"location":"references/standard-packages/random/#random-package","text":"This package provides random number generation. { \"type\": \"system\" }","title":"Random package"},{"location":"references/standard-packages/random/#install","text":"{ \"dependencies\": { \"Random\": \"pen:///random\" } }","title":"Install"},{"location":"references/standard-packages/random/#randomcontext-module","text":"","title":"Random'Context module"},{"location":"references/standard-packages/random/#types","text":"","title":"Types"},{"location":"references/standard-packages/random/#context","text":"A context of random number generation. type Context = context'Context","title":"Context"},{"location":"references/standard-packages/random/#functions","text":"No functions are defined.","title":"Functions"},{"location":"references/standard-packages/random/#randomrandom-module","text":"","title":"Random'Random module"},{"location":"references/standard-packages/random/#types_1","text":"No types are defined.","title":"Types"},{"location":"references/standard-packages/random/#functions_1","text":"","title":"Functions"},{"location":"references/standard-packages/random/#number","text":"Generate a random number in a range of [0, 1). \\(ctx Context) number","title":"Number"},{"location":"references/standard-packages/reflect/","text":"Reflect package This package provides reflection. { \"type\": \"library\" } Install { \"dependencies\": { \"Reflect\": \"pen:///reflect\" } } Reflect'Any module This module provides utility functions for the any type. Types No types are defined. Functions Debug Pretty-print a value. \\(x any) string Equal Check if values are equal. It returns none if values are not comparable. \\(x any, y any) boolean | none","title":"Reflect"},{"location":"references/standard-packages/reflect/#reflect-package","text":"This package provides reflection. { \"type\": \"library\" }","title":"Reflect package"},{"location":"references/standard-packages/reflect/#install","text":"{ \"dependencies\": { \"Reflect\": \"pen:///reflect\" } }","title":"Install"},{"location":"references/standard-packages/reflect/#reflectany-module","text":"This module provides utility functions for the any type.","title":"Reflect'Any module"},{"location":"references/standard-packages/reflect/#types","text":"No types are defined.","title":"Types"},{"location":"references/standard-packages/reflect/#functions","text":"","title":"Functions"},{"location":"references/standard-packages/reflect/#debug","text":"Pretty-print a value. \\(x any) string","title":"Debug"},{"location":"references/standard-packages/reflect/#equal","text":"Check if values are equal. It returns none if values are not comparable. \\(x any, y any) boolean | none","title":"Equal"},{"location":"references/standard-packages/regex/","text":"Regex package This package provides regular expressions. { \"type\": \"library\" } Install { \"dependencies\": { \"Regex\": \"pen:///regex\" } } Regex'Expression module This module provides functions to compile and match regular expressions. Types Expression A regular expression. type Expression { # ... } Functions New Compile a regular expression. \\(s string) Expression | error Matches Check if a regular expression matches with a string or not. \\(e Expression, s string) boolean Match Match a regular expression with a string and return matched groups. \\(e Expression, s string) [string | none] | none","title":"Regex"},{"location":"references/standard-packages/regex/#regex-package","text":"This package provides regular expressions. { \"type\": \"library\" }","title":"Regex package"},{"location":"references/standard-packages/regex/#install","text":"{ \"dependencies\": { \"Regex\": \"pen:///regex\" } }","title":"Install"},{"location":"references/standard-packages/regex/#regexexpression-module","text":"This module provides functions to compile and match regular expressions.","title":"Regex'Expression module"},{"location":"references/standard-packages/regex/#types","text":"","title":"Types"},{"location":"references/standard-packages/regex/#expression","text":"A regular expression. type Expression { # ... }","title":"Expression"},{"location":"references/standard-packages/regex/#functions","text":"","title":"Functions"},{"location":"references/standard-packages/regex/#new","text":"Compile a regular expression. \\(s string) Expression | error","title":"New"},{"location":"references/standard-packages/regex/#matches","text":"Check if a regular expression matches with a string or not. \\(e Expression, s string) boolean","title":"Matches"},{"location":"references/standard-packages/regex/#match","text":"Match a regular expression with a string and return matched groups. \\(e Expression, s string) [string | none] | none","title":"Match"},{"location":"references/standard-packages/sql/","text":"Sql package This package provides a SQL database client. { \"type\": \"system\" } Install { \"dependencies\": { \"Sql\": \"pen:///sql\" } } Sql'Context module Types Context A SQL database context type Context = context'Context Functions No functions are defined. Sql'Pool module Types Pool A connection pool type Pool = pool'Pool Functions New Create a connection pool. \\(context Context, uri string, options Options) Pool | error Query Run a query and return its rows. \\(context Context, pool Pool, query string, arguments [Value]) [[Value]] | error Execute Run a query and return a number of affected rows. \\(context Context, pool Pool, query string, arguments [Value]) number | error Sql'Pool'Options module Types Options Connection pool options type Options { MinConnections number MaxConnections number ConnectTimeout number } Functions No functions are defined. Sql'Value module Types Value A value in a column type Value = boolean | none | number | string Functions No functions are defined.","title":"Sql"},{"location":"references/standard-packages/sql/#sql-package","text":"This package provides a SQL database client. { \"type\": \"system\" }","title":"Sql package"},{"location":"references/standard-packages/sql/#install","text":"{ \"dependencies\": { \"Sql\": \"pen:///sql\" } }","title":"Install"},{"location":"references/standard-packages/sql/#sqlcontext-module","text":"","title":"Sql'Context module"},{"location":"references/standard-packages/sql/#types","text":"","title":"Types"},{"location":"references/standard-packages/sql/#context","text":"A SQL database context type Context = context'Context","title":"Context"},{"location":"references/standard-packages/sql/#functions","text":"No functions are defined.","title":"Functions"},{"location":"references/standard-packages/sql/#sqlpool-module","text":"","title":"Sql'Pool module"},{"location":"references/standard-packages/sql/#types_1","text":"","title":"Types"},{"location":"references/standard-packages/sql/#pool","text":"A connection pool type Pool = pool'Pool","title":"Pool"},{"location":"references/standard-packages/sql/#functions_1","text":"","title":"Functions"},{"location":"references/standard-packages/sql/#new","text":"Create a connection pool. \\(context Context, uri string, options Options) Pool | error","title":"New"},{"location":"references/standard-packages/sql/#query","text":"Run a query and return its rows. \\(context Context, pool Pool, query string, arguments [Value]) [[Value]] | error","title":"Query"},{"location":"references/standard-packages/sql/#execute","text":"Run a query and return a number of affected rows. \\(context Context, pool Pool, query string, arguments [Value]) number | error","title":"Execute"},{"location":"references/standard-packages/sql/#sqlpooloptions-module","text":"","title":"Sql'Pool'Options module"},{"location":"references/standard-packages/sql/#types_2","text":"","title":"Types"},{"location":"references/standard-packages/sql/#options","text":"Connection pool options type Options { MinConnections number MaxConnections number ConnectTimeout number }","title":"Options"},{"location":"references/standard-packages/sql/#functions_2","text":"No functions are defined.","title":"Functions"},{"location":"references/standard-packages/sql/#sqlvalue-module","text":"","title":"Sql'Value module"},{"location":"references/standard-packages/sql/#types_3","text":"","title":"Types"},{"location":"references/standard-packages/sql/#value","text":"A value in a column type Value = boolean | none | number | string","title":"Value"},{"location":"references/standard-packages/sql/#functions_3","text":"No functions are defined.","title":"Functions"},{"location":"references/standard-packages/test/","text":"Test package This package provides test utilities. { \"type\": \"library\" } Install { \"dependencies\": { \"Test\": \"pen:///test\" } } Test'Assert module This module provides a collection of assertion logic for testing. Types No types are defined. Functions Equal Assert that values are equal. Also, if it finds values not comparable, it returns an error. \\(x any, y any) none | error True Assert that a condition is true. \\(x boolean) none | error Error Check if a value is an error. \\(x any) none | error Fail Fail with an error immediately. This function is useful to make unreachable codes fail. \\() error Test'State module This module provides mutable states. They are useful to test certain kinds of side effects, such as I/O. Types State A mutable state type State { # ... } Functions Run Run a function with a state. \\(f \\(State) none | error) none | error Get Get a value from a state. \\(s State) any Set Set a value to a state. \\(s State, x any) none","title":"Test"},{"location":"references/standard-packages/test/#test-package","text":"This package provides test utilities. { \"type\": \"library\" }","title":"Test package"},{"location":"references/standard-packages/test/#install","text":"{ \"dependencies\": { \"Test\": \"pen:///test\" } }","title":"Install"},{"location":"references/standard-packages/test/#testassert-module","text":"This module provides a collection of assertion logic for testing.","title":"Test'Assert module"},{"location":"references/standard-packages/test/#types","text":"No types are defined.","title":"Types"},{"location":"references/standard-packages/test/#functions","text":"","title":"Functions"},{"location":"references/standard-packages/test/#equal","text":"Assert that values are equal. Also, if it finds values not comparable, it returns an error. \\(x any, y any) none | error","title":"Equal"},{"location":"references/standard-packages/test/#true","text":"Assert that a condition is true. \\(x boolean) none | error","title":"True"},{"location":"references/standard-packages/test/#error","text":"Check if a value is an error. \\(x any) none | error","title":"Error"},{"location":"references/standard-packages/test/#fail","text":"Fail with an error immediately. This function is useful to make unreachable codes fail. \\() error","title":"Fail"},{"location":"references/standard-packages/test/#teststate-module","text":"This module provides mutable states. They are useful to test certain kinds of side effects, such as I/O.","title":"Test'State module"},{"location":"references/standard-packages/test/#types_1","text":"","title":"Types"},{"location":"references/standard-packages/test/#state","text":"A mutable state type State { # ... }","title":"State"},{"location":"references/standard-packages/test/#functions_1","text":"","title":"Functions"},{"location":"references/standard-packages/test/#run","text":"Run a function with a state. \\(f \\(State) none | error) none | error","title":"Run"},{"location":"references/standard-packages/test/#get","text":"Get a value from a state. \\(s State) any","title":"Get"},{"location":"references/standard-packages/test/#set","text":"Set a value to a state. \\(s State, x any) none","title":"Set"}]}