import Core'Boolean
import Core'Number
import Core'String
import Core'String'Byte
import Core'String'Byte'View { View }

import 'Value { Value }

import foreign "c" _pen_json_decode_number \(string) number

type valueResult {
  value Value
  input View
}

type stringResult {
  string string
  input View
}

type stringsResult {
  strings [string]
  input View
}

type arrayResult {
  array [Value]
  input View
}

type objectResult {
  entries [objectEntry]
  input View
}

type objectEntry {
  key string
  value Value
}

# Decode a string into a JSON value.
Decode = \(s string) Value | error {
  r = value(View'New(s))?

  if View'Length(blank(r.input)) == 0 {
    r.value
  } else {
    error("unexpected character")
  }
}

value = \(v View) valueResult | error {
  v = blank(v)

  if View'HasPrefix(v, "n") {
    null(v)
  } else if View'HasPrefix(v, "t") {
    booleanTrue(v)
  } else if View'HasPrefix(v, "f") {
    booleanFalse(v)
  } else if View'HasPrefix(v, "\"") {
    string(v)
  } else if View'HasPrefix(v, "[") {
    array(v)
  } else if View'HasPrefix(v, "{") {
    object(v)
  } else {
    number(v)
  }
}

null = \(v View) valueResult | error {
  s = "null"

  if View'HasPrefix(v, s) {
    valueResult{
      value: Value'New(none),
      input: View'Seek(v, Byte'Length(s)),
    }
  } else {
    error("null expected")
  }
}

booleanTrue = \(v View) valueResult | error {
  s = "true"

  if View'HasPrefix(v, s) {
    valueResult{
      value: Value'New(true),
      input: View'Seek(v, Byte'Length(s)),
    }
  } else {
    error("true expected")
  }
}

booleanFalse = \(v View) valueResult | error {
  s = "false"

  if View'HasPrefix(v, s) {
    valueResult{
      value: Value'New(false),
      input: View'Seek(v, Byte'Length(s)),
    }
  } else {
    error("false expected")
  }
}

string = \(v View) valueResult | error {
  r = stringCharacters(View'Seek(v, 1))?

  valueResult{
    value: Value'New(String'Concatenate(r.strings)),
    input: View'Seek(r.input, 1),
  }
}

stringCharacters = \(v View) stringsResult | error {
  if View'HasPrefix(v, "\"") {
    stringsResult([string], v)
  } else {
    r = stringCharacter(v)?
    s = r.string
    r = stringCharacters(r.input)?

    stringsResult([string s, ...r.strings], r.input)
  }
}

stringCharacter = \(v View) stringResult | error {
  if View'HasPrefix(v, "\\\"") {
    stringResult("\"", View'Seek(v, 2))
  } else if View'Length(v) == 0 {
    error("unexpected end of string")
  } else {
    stringResult(Byte'Slice(View'ToString(v), 1, 1), View'Seek(v, 1))
  }
}

number = \(v View) valueResult | error {
  i = View'Start(v)

  v = if View'HasPrefix(v, "-") { View'Seek(v, 1) } else { v }
  v = integer(v)?
  v = if View'HasPrefix(v, ".") { digits(View'Seek(v, 1)) } else { v }

  valueResult{
    value: Value'New(
      _pen_json_decode_number(Byte'Slice(View'Viewee(v), i, View'Start(v) - 1)),
    ),
    input: v,
  }
}

integer = \(v View) View | error {
  if w = nonZeroDigit(v) as View {
    digits(w)
  } else {
    if View'HasPrefix(v, "0") {
      View'Seek(v, 1)
    } else {
      error("number expected")
    }
  }
}

digits = \(v View) View {
  if w = digit(v) as View {
    digits(w)
  } else {
    v
  }
}

digit = \(v View) View | none {
  if w = nonZeroDigit(v) as View {
    w
  } else {
    if View'HasPrefix(v, "0") {
      View'Seek(v, 1)
    } else {
      none
    }
  }
}

nonZeroDigit = \(v View) View | none {
  if Boolean'Any([boolean View'HasPrefix(v, Number'String(n())) for n in Number'Range(1, 9)]) {
    View'Seek(v, 1)
  } else {
    none
  }
}

array = \(v View) valueResult | error {
  if View'HasPrefix(v, "[") {
    r = arrayElements(View'Seek(v, 1), [Value])?
    v = blank(r.input)

    if View'HasPrefix(v, "]") {
      valueResult(Value'New(r.array), View'Seek(v, 1))
    } else {
      error("] expected")
    }
  } else {
    error("array expected")
  }
}

arrayElements = \(v View, vs [Value]) arrayResult | error {
  if r = value(v) as valueResult {
    # TODO Optimize appending list elements. This is O(n^2).
    vs = [Value ...vs, r.value]
    v = blank(r.input)

    if View'HasPrefix(v, ",") {
      v = blank(View'Seek(v, 1))

      if View'HasPrefix(v, "]") {
        error("unexpected ]")
      } else {
        arrayElements(v, vs)
      }
    } else {
      arrayResult{array: vs, input: v}
    }
  } else {
    arrayResult{array: vs, input: v}
  }
}

object = \(v View) valueResult | error {
  if View'HasPrefix(v, "{") {
    r = objectEntries(View'Seek(v, 1), [objectEntry])?
    v = blank(r.input)

    if View'HasPrefix(v, "}") {
      valueResult(Value'New(entriesToMap(r.entries)), View'Seek(v, 1))
    } else {
      error("} expected")
    }
  } else {
    error("{ expected")
  }
}

objectEntries = \(v View, es [objectEntry]) objectResult | error {
  v = blank(v)

  if r = string(v) as valueResult {
    k = if k = Value'Raw(r.value) as string { k } else { error("unexpected non-string key") }?
    v = blank(r.input)
    v = if View'HasPrefix(v, ":") { View'Seek(v, 1) } else { error(": expected") }?
    r = value(v)?

    # TODO Optimize appending list elements. This is O(n^2).
    es = [objectEntry ...es, objectEntry{key: k, value: r.value}]
    v = blank(r.input)

    if View'HasPrefix(v, ",") {
      v = blank(View'Seek(v, 1))

      if View'HasPrefix(v, "]") {
        error("unexpected ]")
      } else {
        objectEntries(v, es)
      }
    } else {
      objectResult{entries: es, input: r.input}
    }
  } else {
    objectResult{entries: es, input: v}
  }
}

entriesToMap = \(es [objectEntry]) {string: Value} {
  if [e, ...es] = es {
    {string: Value e().key: e().value, ...entriesToMap(es)}
  } else {
    {string: Value}
  }
}

blank = \(v View) View {
  if View'HasPrefix(v, " ") | View'HasPrefix(v, "\t") | View'HasPrefix(v, "\n") {
    blank(View'Seek(v, 1))
  } else {
    v
  }
}
