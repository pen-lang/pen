import 'List
import 'Map'StringMap'stringToStringMap as map
import 'Number
import Test'Assert

TestMapNew = \() none | error {
  m = map'New()

  Assert'EqualNumbers(map'Size(m), 0)
}

TestMapSet = \() none | error {
  m = map'Set(map'New(), "", "")

  Assert'EqualNumbers(map'Size(m), 1)
}

TestMapSetTwice = \() none | error {
  m = map'Set(map'New(), "foo", "")
  m = map'Set(m, "bar", "")

  Assert'EqualNumbers(map'Size(m), 2)
}

TestMapSetSameTwice = \() none | error {
  m = map'Set(map'New(), "foo", "")
  m = map'Set(m, "foo", "")

  Assert'EqualNumbers(map'Size(m), 1)
}

TestMapGet = \() none | error {
  key = "foo"
  value = "bar"

  m = map'Set(map'New(), key, value)

  Assert'True(map'Get(m, key) == value)
}

TestMapGetFail = \() none | error {
  Assert'True(map'Get(map'New(), "foo") == none)
}

TestMapSetManyTimes = \() none | error {
  n = 1000
  m = setMany(map'New(), n)

  Assert'EqualNumbers(map'Size(m), n)?
  assertGetMany(m, Number'Sequence(n))
}

TestMapDeleteManyTimes = \() none | error {
  n = 1000
  m = setMany(map'New(), n)
  m = deleteMany(m, n / 2)

  Assert'EqualNumbers(map'Size(m), n / 2)?
  assertGetMany(m, Number'Range(n / 2 + 1, n))
}

TestMapKeys = \() none | error {
  n = 1000
  m = setMany(map'New(), n)

  Assert'EqualNumbers(List'Length([any ...map'Keys(m)]), n)
}

TestMapValues = \() none | error {
  n = 1000
  m = setMany(map'New(), n)

  Assert'EqualNumbers(List'Length([any ...map'Values(m)]), n)
}

assertGetMany = \(m map'Map, ns [number]) none | error {
  if [n, ...ns] = ns {
    s = Number'String(n())
    Assert'True(map'Get(m, s) == s)?
    assertGetMany(m, ns)
  } else {
    none
  }
}

TestMapMerge = \() none | error {
  m = map'Merge(
    map'Set(map'New(), "foo", "foo"),
    map'Set(map'New(), "bar", "bar"),
  )

  Assert'True(map'Get(m, "foo") == "foo")
  Assert'True(map'Get(m, "bar") == "bar")
}

setMany = \(m map'Map, n number) map'Map {
  if n == 0 {
    m
  } else {
    s = Number'String(n)
    setMany(map'Set(m, s, s), n - 1)
  }
}

deleteMany = \(m map'Map, n number) map'Map {
  if n == 0 {
    m
  } else {
    deleteMany(map'Delete(m, Number'String(n)), n - 1)
  }
}
