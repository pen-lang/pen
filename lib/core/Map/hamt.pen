import 'Bit
import 'Map'noValue { NoValue }

# The first argument is a hash value.
# The second argument is a layer index.
import foreign "c" _pen_core_hamt_hash_key \(number, number) number

type keyValue {
  key any
  value any
}

type Configuration {
  EqualKeys \(any, any) boolean
  HashKey \(any) number
}

type Update {
  Hamt Hamt
  Size boolean
}

type Entry = keyValue | Hamt | none

type Hamt {
  entry1 Entry
  entry2 Entry
  entry3 Entry
  entry4 Entry
  entry5 Entry
  entry6 Entry
  entry7 Entry
  entry8 Entry
  entry9 Entry
  entry10 Entry
  entry11 Entry
  entry12 Entry
  entry13 Entry
  entry14 Entry
  entry15 Entry
  entry16 Entry
  entry17 Entry
  entry18 Entry
  entry19 Entry
  entry20 Entry
  entry21 Entry
  entry22 Entry
  entry23 Entry
  entry24 Entry
  entry25 Entry
  entry26 Entry
  entry27 Entry
  entry28 Entry
  entry29 Entry
  entry30 Entry
  entry31 Entry
  entry32 Entry
}

maxLevel = \() number { 60 / 5 }

maxIndex = \() number { 32 }

New = \() Hamt {
  Hamt{
    entry1: none,
    entry2: none,
    entry3: none,
    entry4: none,
    entry5: none,
    entry6: none,
    entry7: none,
    entry8: none,
    entry9: none,
    entry10: none,
    entry11: none,
    entry12: none,
    entry13: none,
    entry14: none,
    entry15: none,
    entry16: none,
    entry17: none,
    entry18: none,
    entry19: none,
    entry20: none,
    entry21: none,
    entry22: none,
    entry23: none,
    entry24: none,
    entry25: none,
    entry26: none,
    entry27: none,
    entry28: none,
    entry29: none,
    entry30: none,
    entry31: none,
    entry32: none,
  }
}

Get = \(hamt Hamt, key any, cfg Configuration) any {
  get(hamt, key, 1, 1, cfg)
}

# A layer is composed of a tree of HAMT and used to re-hash keys.
# A level is composed of a node of HAMT and used to segment hash values into entry indexes.
get = \(hamt Hamt, key any, layer number, level number, cfg Configuration) any {
  if e = getEntry(hamt, index(key, layer, level, cfg)) as keyValue {
    if cfg.EqualKeys(e.key, key) {
      e.value
    } else {
      NoValue{}
    }
  } else if Hamt {
    if level > maxLevel() {
      get(e, key, layer + 1, 1, cfg)
    } else {
      get(e, key, layer, level + 1, cfg)
    }
  } else if none {
    NoValue{}
  }
}

Set = \(hamt Hamt, key any, value any, cfg Configuration) Update {
  set(hamt, key, value, 1, 1, cfg)
}

set = \(hamt Hamt, key any, value any, layer number, level number, cfg Configuration) Update {
  i = index(key, layer, level, cfg)
  update = \(e Entry, size boolean) Update {
    Update{Hamt: setEntry(hamt, i, e), Size: size}
  }

  if e = getEntry(hamt, i) as keyValue {
    if cfg.EqualKeys(e.key, key) {
      update(keyValue{key: key, value: value}, false)
    } else {
      l = level + 1
      u = set(New(), e.key, e.value, layer, l, cfg)
      u = set(u.Hamt, key, value, layer, l, cfg)

      update(u.Hamt, true)
    }
  } else if Hamt {
    u = if level > maxLevel() {
      set(e, key, value, layer + 1, 1, cfg)
    } else {
      set(e, key, value, layer, level + 1, cfg)
    }

    update(u.Hamt, u.Size)
  } else if none {
    update(keyValue{key: key, value: value}, true)
  }
}

Delete = \(hamt Hamt, key any, cfg Configuration) Update {
  delete(hamt, key, 1, 1, cfg)
}

# TODO Normalize tree structures.
delete = \(hamt Hamt, key any, layer number, level number, cfg Configuration) Update {
  i = index(key, layer, level, cfg)
  update = \(e Entry, size boolean) Update {
    Update{Hamt: setEntry(hamt, i, e), Size: size}
  }

  if e = getEntry(hamt, i) as keyValue {
    if cfg.EqualKeys(e.key, key) {
      update(none, true)
    } else {
      Update{Hamt: hamt, Size: false}
    }
  } else if Hamt {
    u = if level > maxLevel() {
      delete(e, key, layer + 1, 1, cfg)
    } else {
      delete(e, key, layer, level + 1, cfg)
    }

    update(u.Hamt, u.Size)
  } else if none {
    Update{Hamt: hamt, Size: false}
  }
}

index = \(key any, layer number, level number, cfg Configuration) number {
  Bit'FromInteger64(
    Bit'And(
      Bit'RightShift(
        _pen_core_hamt_hash_key(cfg.HashKey(key), layer),
        5 * (level - 1),
      ),
      Bit'ToInteger64(0b11111),
    ),
  )
    + 1
}

Keys = \(m Hamt) [any] {
  keys(m, 1)
}

keys = \(m Hamt, i number) [any] {
  if i > maxIndex() {
    [any]
  } else {
    if e = getEntry(m, i) as keyValue {
      [any e.key, ...keys(m, i + 1)]
    } else if Hamt {
      [any ...Keys(e), ...keys(m, i + 1)]
    } else if none {
      keys(m, i + 1)
    }
  }
}

getEntry = \(hamt Hamt, index number) Entry {
  if index == 1 {
    hamt.entry1
  } else if index == 2 {
    hamt.entry2
  } else if index == 3 {
    hamt.entry3
  } else if index == 4 {
    hamt.entry4
  } else if index == 5 {
    hamt.entry5
  } else if index == 6 {
    hamt.entry6
  } else if index == 7 {
    hamt.entry7
  } else if index == 8 {
    hamt.entry8
  } else if index == 9 {
    hamt.entry9
  } else if index == 10 {
    hamt.entry10
  } else if index == 11 {
    hamt.entry11
  } else if index == 12 {
    hamt.entry12
  } else if index == 13 {
    hamt.entry13
  } else if index == 14 {
    hamt.entry14
  } else if index == 15 {
    hamt.entry15
  } else if index == 16 {
    hamt.entry16
  } else if index == 17 {
    hamt.entry17
  } else if index == 18 {
    hamt.entry18
  } else if index == 19 {
    hamt.entry19
  } else if index == 20 {
    hamt.entry20
  } else if index == 21 {
    hamt.entry21
  } else if index == 22 {
    hamt.entry22
  } else if index == 23 {
    hamt.entry23
  } else if index == 24 {
    hamt.entry24
  } else if index == 25 {
    hamt.entry25
  } else if index == 26 {
    hamt.entry26
  } else if index == 27 {
    hamt.entry27
  } else if index == 28 {
    hamt.entry28
  } else if index == 29 {
    hamt.entry29
  } else if index == 30 {
    hamt.entry30
  } else if index == 31 {
    hamt.entry31
  } else {
    hamt.entry32
  }
}

setEntry = \(hamt Hamt, index number, entry Entry) Hamt {
  if index == 1 {
    Hamt{...hamt, entry1: entry}
  } else if index == 2 {
    Hamt{...hamt, entry2: entry}
  } else if index == 3 {
    Hamt{...hamt, entry3: entry}
  } else if index == 4 {
    Hamt{...hamt, entry4: entry}
  } else if index == 5 {
    Hamt{...hamt, entry5: entry}
  } else if index == 6 {
    Hamt{...hamt, entry6: entry}
  } else if index == 7 {
    Hamt{...hamt, entry7: entry}
  } else if index == 8 {
    Hamt{...hamt, entry8: entry}
  } else if index == 9 {
    Hamt{...hamt, entry9: entry}
  } else if index == 10 {
    Hamt{...hamt, entry10: entry}
  } else if index == 11 {
    Hamt{...hamt, entry11: entry}
  } else if index == 12 {
    Hamt{...hamt, entry12: entry}
  } else if index == 13 {
    Hamt{...hamt, entry13: entry}
  } else if index == 14 {
    Hamt{...hamt, entry14: entry}
  } else if index == 15 {
    Hamt{...hamt, entry15: entry}
  } else if index == 16 {
    Hamt{...hamt, entry16: entry}
  } else if index == 17 {
    Hamt{...hamt, entry17: entry}
  } else if index == 18 {
    Hamt{...hamt, entry18: entry}
  } else if index == 19 {
    Hamt{...hamt, entry19: entry}
  } else if index == 20 {
    Hamt{...hamt, entry20: entry}
  } else if index == 21 {
    Hamt{...hamt, entry21: entry}
  } else if index == 22 {
    Hamt{...hamt, entry22: entry}
  } else if index == 23 {
    Hamt{...hamt, entry23: entry}
  } else if index == 24 {
    Hamt{...hamt, entry24: entry}
  } else if index == 25 {
    Hamt{...hamt, entry25: entry}
  } else if index == 26 {
    Hamt{...hamt, entry26: entry}
  } else if index == 27 {
    Hamt{...hamt, entry27: entry}
  } else if index == 28 {
    Hamt{...hamt, entry28: entry}
  } else if index == 29 {
    Hamt{...hamt, entry29: entry}
  } else if index == 30 {
    Hamt{...hamt, entry30: entry}
  } else if index == 31 {
    Hamt{...hamt, entry31: entry}
  } else {
    Hamt{...hamt, entry32: entry}
  }
}
