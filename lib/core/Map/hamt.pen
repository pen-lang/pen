import 'Bit
import 'Map'emptyEntry { EmptyEntry }

import foreign "c" _pen_core_hamt_hash_key \(string, number) number

type keyValue {
  key string
  value any
}

type Update {
  Hamt Hamt
  New boolean
}

type Entry = keyValue | Hamt | none

type Hamt {
  entry1 Entry
  entry2 Entry
  entry3 Entry
  entry4 Entry
  entry5 Entry
  entry6 Entry
  entry7 Entry
  entry8 Entry
  entry9 Entry
  entry10 Entry
  entry11 Entry
  entry12 Entry
  entry13 Entry
  entry14 Entry
  entry15 Entry
  entry16 Entry
  entry17 Entry
  entry18 Entry
  entry19 Entry
  entry20 Entry
  entry21 Entry
  entry22 Entry
  entry23 Entry
  entry24 Entry
  entry25 Entry
  entry26 Entry
  entry27 Entry
  entry28 Entry
  entry29 Entry
  entry30 Entry
  entry31 Entry
  entry32 Entry
}

maxLevel = \() number { 60 / 5 }

New = \() Hamt {
  Hamt{
    entry1: none,
    entry2: none,
    entry3: none,
    entry4: none,
    entry5: none,
    entry6: none,
    entry7: none,
    entry8: none,
    entry9: none,
    entry10: none,
    entry11: none,
    entry12: none,
    entry13: none,
    entry14: none,
    entry15: none,
    entry16: none,
    entry17: none,
    entry18: none,
    entry19: none,
    entry20: none,
    entry21: none,
    entry22: none,
    entry23: none,
    entry24: none,
    entry25: none,
    entry26: none,
    entry27: none,
    entry28: none,
    entry29: none,
    entry30: none,
    entry31: none,
    entry32: none,
  }
}

Get = \(hamt Hamt, key string) any {
  getInLayer(hamt, key, 1, 1)
}

# A layer is composed of a tree of HAMT and used to re-hash keys.
# A level is composed of a node of HAMT and used to segment hash values into entry indexes.
getInLayer = \(hamt Hamt, key string, layer number, level number) any {
  getWithHash(hamt, key, _pen_core_hamt_hash_key(key, layer), layer, level)
}

getWithHash = \(hamt Hamt, key string, hash number, layer number, level number) any {
  if e = getEntry(hamt, index(hash)) as keyValue {
    e.value
  } else if Hamt {
    if level > maxLevel() {
      getInLayer(e, key, layer + 1, 1)
    } else {
      getWithHash(e, key, shiftHash(hash), layer, level + 1)
    }
  } else if none {
    EmptyEntry{}
  }
}

Set = \(hamt Hamt, key string, value any) Update {
  setInLayer(hamt, key, value, 1, 1)
}

setInLayer = \(hamt Hamt, key string, value any, layer number, level number) Update {
  setWithHash(hamt, key, _pen_core_hamt_hash_key(key, layer), value, layer, level)
}

setWithHash = \(hamt Hamt, key string, hash number, value any, layer number, level number) Update {
  i = 0

  if e = getEntry(hamt, i) as keyValue {
    if e.key == key {
      Update{Hamt: hamt, New: true}
    } else {
      l = level + 1
      u = setInLayer(New(), e.key, e.value, layer, l)
      uu = setInLayer(u.Hamt, key, value, layer, l)

      Update{Hamt: hamt, New: true}
    }
  } else {
    Update{Hamt: hamt, New: true}
  }
}

index = \(hash number) number {
  0
}

shiftHash = \(hash number) number {
  0
}

getEntry = \(hamt Hamt, index number) Entry {
    hamt.entry32
}

setEntry = \(hamt Hamt, index number, entry Entry) Hamt {
    Hamt{...hamt, entry32: entry}
}
