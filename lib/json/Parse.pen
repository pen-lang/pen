import Core'String
import Core'String'Byte
import Core'String'Byte'View { View }
import 'Value { Value }

type state {
  value Value
  input View
}

type stringState {
  value string
  input View
}

state = \(v Value, i View) state {
  state{value: v, input: i}
}

stringState = \(s string, i View) stringState {
  stringState{value: s, input: i}
}

Parse = \(s string) Value | error {
  parseAtomic(View'New(s))?.value
}

parseAtomic = \(v View) state | error {
  v = whitespaces(v)

  if View'HasPrefix(v, "n") {
    null(v)
  } else if View'HasPrefix(v, "t") {
    true_(v)
  } else if View'HasPrefix(v, "f") {
    false_(v)
  } else if View'HasPrefix(v, "\"") {
    string_(v)
  } else {
    number_(v)
  }
}

null = \(v View) state | error {
  s = "null"

  if View'HasPrefix(v, s) {
    state(Value'New(none), View'Seek(v, Byte'Length(s)))
  } else {
    error("null expected")
  }
}

true_ = \(v View) state | error {
  s = "true"

  if View'HasPrefix(v, s) {
    state(Value'New(true), View'Seek(v, Byte'Length(s)))
  } else {
    error("true expected")
  }
}

false_ = \(v View) state | error {
  s = "false"

  if View'HasPrefix(v, s) {
    state(Value'New(false), View'Seek(v, Byte'Length(s)))
  } else {
    error("false expected")
  }
}

string_ = \(v View) state | error {
  s = stringCharacters(View'Seek(v, 1), [string])

  state(Value'New(s.value), View'Seek(s.input, 1))
}

stringCharacters = \(v View, ss [string]) stringState {
  if s = stringCharacter(v) as none {
    stringState(String'Join(ss, ""), v)
  } else {
    # TODO Optimize appending string elements.
    stringCharacters(s.input, [string ...ss, s.value])
  }
}

stringCharacter = \(v View) stringState | none {
  if View'HasPrefix(v, "\\\"") {
    stringState("\"", View'Seek(v, 2))
  } else if View'HasPrefix(v, "\"") {
    none
  } else {
    stringState(Byte'Slice(View'ToString(v), 1, 1), View'Seek(v, 1))
  }
}

number_ = \(v View) state | error {
  # TODO
  error("not implemented")
}

whitespaces = \(v View) View {
  if vv = whitespace(v) as View {
    whitespaces(vv)
  } else {
    v
  }
}

whitespace = \(v View) View | none {
  if View'HasPrefix(v, " ") | View'HasPrefix(v, "\t") | View'HasPrefix(v, "\n") {
    View'Seek(v, 1)
  } else {
    none
  }
}
