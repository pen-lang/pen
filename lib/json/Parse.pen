import Core'String'Byte
import Core'String'Byte'View { View }
import 'Value { Value }

type state {
  value Value
  input View
}

nullLiteral = \() string { "null" }

trueLiteral = \() string { "true" }

falseLiteral = \() string { "false" }

state = \(v Value, i View) state {
  state{value: v, input: i}
}

Parse = \(s string) Value | error {
  parseAtomic(View'New(s))?.value
}

parseAtomic = \(v View) state | error {
  v = whitespaces(v)

  if View'HasPrefix(v, nullLiteral()) {
    state(Value'New(none), View'Seek(v, Byte'Length(nullLiteral())))
  } else if View'HasPrefix(v, trueLiteral()) {
    state(Value'New(true), View'Seek(v, Byte'Length(trueLiteral())))
  } else if View'HasPrefix(v, falseLiteral()) {
    state(Value'New(false), View'Seek(v, Byte'Length(falseLiteral())))
  } else if View'HasPrefix(v, "\"") {
    string_(v)
  } else {
    number_(v)
  }
}

string_ = \(v View) state | error {
  # TODO
  error("not implemented")
}

number_ = \(v View) state | error {
  # TODO
  error("not implemented")
}

whitespaces = \(v View) View {
  if vv = whitespace(v) as View {
    whitespaces(vv)
  } else {
    v
  }
}

whitespace = \(v View) View | none {
  if View'HasPrefix(v, " ") | View'HasPrefix(v, "\t") | View'HasPrefix(v, "\n") {
    View'Seek(v, 1)
  } else {
    none
  }
}
