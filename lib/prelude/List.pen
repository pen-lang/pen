type _AnyList {
  node \() _node | none
}

type _node {
  first \() any
  rest \() _node | none
}

type _FirstRest {
  first \() any
  rest _AnyList
}

_first = \(fr _FirstRest) \() any {
  fr.first
}

_rest = \(fr _FirstRest) _AnyList {
  fr.rest
}

_firstRest = \(l _AnyList) _FirstRest | none {
  if n = l.node() as _node {
    _FirstRest{
      first: n.first,
      rest: _AnyList{node: n.rest},
    }
  } else {
    none
  }
}

_emptyList = \() _AnyList {
  _AnyList{node: \() _node | none { none }}
}

_prependToList = \(x \() any, l _AnyList) _AnyList {
  _AnyList{node: \() _node | none { _prependToNode(x, l.node) }}
}

_prependToNode = \(x \() any, n \() _node | none) _node {
  _node{
    first: x,
    rest: n,
  }
}

_lazy = \(x \() _AnyList) _AnyList {
  _AnyList{
    node: \() _node | none {
      x().node()
    }
  }
}

_concatenateLists = \(x \() _AnyList, y _AnyList) _AnyList {
  _AnyList{
    node: \() _node | none {
      if x = x().node() as _node {
        _prependToNode(x.first, _concatenateNodes(x.rest, y.node))
      } else {
        y.node()
      }
    }
  }
}

_concatenateNodes = \(x \() _node | none, y \() _node | none) \() _node | none {
  \() _node | none {
    if x = x() as _node {
      _prependToNode(x.first, _concatenateNodes(x.rest, y))
    } else {
      y()
    }
  }
}

_equalLists = \(f \(any, any) boolean, x _AnyList, y _AnyList) boolean {
  _equalNodes(f, x.node(), y.node())
}

_equalNodes = \(f \(any, any) boolean, x _node | none, y _node | none) boolean {
  if x = x as _node {
    if y = y as _node {
      f(x.first(), y.first()) & _equalNodes(f, x.rest(), y.rest())
    } else {
      false
    }
  } else {
    if y = y as _node {
      false
    } else {
      true
    }
  }
}
