import foreign "c" _pen_prelude_combine_hashes \(number, number) number
import foreign "c" _pen_prelude_hash_number \(number) number
import foreign "c" _pen_prelude_hash_to_index \(number, number, number) number

type _empty {}

type _keyValue {
  key any
  value any
}

type _configuration {
  EqualKeys \(any, any) boolean
  HashKey \(any) number
}

type _hamtUpdate {
  hamt _hamt
  Size boolean
}

type _entry = _keyValue | _hamt | none

type _hamt {
  entry1 _entry
  entry2 _entry
  entry3 _entry
  entry4 _entry
  entry5 _entry
  entry6 _entry
  entry7 _entry
  entry8 _entry
  entry9 _entry
  entry10 _entry
  entry11 _entry
  entry12 _entry
  entry13 _entry
  entry14 _entry
  entry15 _entry
  entry16 _entry
  entry17 _entry
  entry18 _entry
  entry19 _entry
  entry20 _entry
  entry21 _entry
  entry22 _entry
  entry23 _entry
  entry24 _entry
  entry25 _entry
  entry26 _entry
  entry27 _entry
  entry28 _entry
  entry29 _entry
  entry30 _entry
  entry31 _entry
  entry32 _entry
}

_maxLevel = \() number { 60 / 5 }

_newHamt = \() _hamt {
  _hamt{
    entry1: none,
    entry2: none,
    entry3: none,
    entry4: none,
    entry5: none,
    entry6: none,
    entry7: none,
    entry8: none,
    entry9: none,
    entry10: none,
    entry11: none,
    entry12: none,
    entry13: none,
    entry14: none,
    entry15: none,
    entry16: none,
    entry17: none,
    entry18: none,
    entry19: none,
    entry20: none,
    entry21: none,
    entry22: none,
    entry23: none,
    entry24: none,
    entry25: none,
    entry26: none,
    entry27: none,
    entry28: none,
    entry29: none,
    entry30: none,
    entry31: none,
    entry32: none,
  }
}

_getHamt = \(hamt _hamt, key any, cfg _configuration) any {
  _getValue(hamt, key, 1, 1, cfg)
}

# A layer is composed of a tree of HAMT and used to re-hash keys.
# A level is composed of a node of HAMT and used to segment hash values into entry indexes.
_getValue = \(hamt _hamt, key any, layer number, level number, cfg _configuration) any {
  if e = _getEntry(hamt, _hamtIndex(key, layer, level, cfg)) as _keyValue {
    if cfg.EqualKeys(e.key, key) {
      e.value
    } else {
      _empty{}
    }
  } else if _hamt {
    if level > _maxLevel() {
      _getValue(e, key, layer + 1, 1, cfg)
    } else {
      _getValue(e, key, layer, level + 1, cfg)
    }
  } else if none {
    _empty{}
  }
}

_setHamt = \(hamt _hamt, key any, value any, cfg _configuration) _hamtUpdate {
  _setKeyValue(hamt, key, value, 1, 1, cfg)
}

_setKeyValue = \(hamt _hamt, key any, value any, layer number, level number, cfg _configuration) _hamtUpdate {
  i = _hamtIndex(key, layer, level, cfg)
  update = \(e _entry, size boolean) _hamtUpdate {
    _hamtUpdate{_hamt: _setEntry(hamt, i, e), Size: size}
  }

  if e = _getEntry(hamt, i) as _keyValue {
    # TODO Remove a useless function call below of workaround for a bug in LLVM 13.0.0.
    _pen_prelude_hash_number(42)
    if cfg.EqualKeys(e.key, key) {
      update(_keyValue{key: key, value: value}, false)
    } else {
      l = level + 1
      u = _setKeyValue(_newHamt(), e.key, e.value, layer, l, cfg)
      u = _setKeyValue(u._hamt, key, value, layer, l, cfg)

      update(u._hamt, true)
    }
  } else if _hamt {
    u = if level > _maxLevel() {
      _setKeyValue(e, key, value, layer + 1, 1, cfg)
    } else {
      _setKeyValue(e, key, value, layer, level + 1, cfg)
    }

    update(u._hamt, u.Size)
  } else if none {
    update(_keyValue{key: key, value: value}, true)
  }
}

_deleteHamt = \(hamt _hamt, key any, cfg _configuration) _hamtUpdate {
  _deleteKey(hamt, key, 1, 1, cfg)
}

# TODO Normalize tree structures.
_deleteKey = \(hamt _hamt, key any, layer number, level number, cfg _configuration) _hamtUpdate {
  i = _hamtIndex(key, layer, level, cfg)
  update = \(e _entry, size boolean) _hamtUpdate {
    _hamtUpdate{_hamt: _setEntry(hamt, i, e), Size: size}
  }

  if e = _getEntry(hamt, i) as _keyValue {
    # TODO Remove a useless function call below of workaround for a bug in LLVM 13.0.0.
    _pen_prelude_hash_number(42)
    if cfg.EqualKeys(e.key, key) {
      update(none, true)
    } else {
      _hamtUpdate{_hamt: hamt, Size: false}
    }
  } else if _hamt {
    u = if level > _maxLevel() {
      _deleteKey(e, key, layer + 1, 1, cfg)
    } else {
      _deleteKey(e, key, layer, level + 1, cfg)
    }

    update(u._hamt, u.Size)
  } else if none {
    _hamtUpdate{_hamt: hamt, Size: false}
  }
}

_hamtIndex = \(key any, layer number, level number, cfg _configuration) number {
  _pen_prelude_hash_to_index(cfg.HashKey(key), layer, level)
}

_getEntry = \(hamt _hamt, index number) _entry {
  if index == 1 {
    hamt.entry1
  } else if index == 2 {
    hamt.entry2
  } else if index == 3 {
    hamt.entry3
  } else if index == 4 {
    hamt.entry4
  } else if index == 5 {
    hamt.entry5
  } else if index == 6 {
    hamt.entry6
  } else if index == 7 {
    hamt.entry7
  } else if index == 8 {
    hamt.entry8
  } else if index == 9 {
    hamt.entry9
  } else if index == 10 {
    hamt.entry10
  } else if index == 11 {
    hamt.entry11
  } else if index == 12 {
    hamt.entry12
  } else if index == 13 {
    hamt.entry13
  } else if index == 14 {
    hamt.entry14
  } else if index == 15 {
    hamt.entry15
  } else if index == 16 {
    hamt.entry16
  } else if index == 17 {
    hamt.entry17
  } else if index == 18 {
    hamt.entry18
  } else if index == 19 {
    hamt.entry19
  } else if index == 20 {
    hamt.entry20
  } else if index == 21 {
    hamt.entry21
  } else if index == 22 {
    hamt.entry22
  } else if index == 23 {
    hamt.entry23
  } else if index == 24 {
    hamt.entry24
  } else if index == 25 {
    hamt.entry25
  } else if index == 26 {
    hamt.entry26
  } else if index == 27 {
    hamt.entry27
  } else if index == 28 {
    hamt.entry28
  } else if index == 29 {
    hamt.entry29
  } else if index == 30 {
    hamt.entry30
  } else if index == 31 {
    hamt.entry31
  } else {
    hamt.entry32
  }
}

_setEntry = \(hamt _hamt, index number, entry _entry) _hamt {
  if index == 1 {
    _hamt{...hamt, entry1: entry}
  } else if index == 2 {
    _hamt{...hamt, entry2: entry}
  } else if index == 3 {
    _hamt{...hamt, entry3: entry}
  } else if index == 4 {
    _hamt{...hamt, entry4: entry}
  } else if index == 5 {
    _hamt{...hamt, entry5: entry}
  } else if index == 6 {
    _hamt{...hamt, entry6: entry}
  } else if index == 7 {
    _hamt{...hamt, entry7: entry}
  } else if index == 8 {
    _hamt{...hamt, entry8: entry}
  } else if index == 9 {
    _hamt{...hamt, entry9: entry}
  } else if index == 10 {
    _hamt{...hamt, entry10: entry}
  } else if index == 11 {
    _hamt{...hamt, entry11: entry}
  } else if index == 12 {
    _hamt{...hamt, entry12: entry}
  } else if index == 13 {
    _hamt{...hamt, entry13: entry}
  } else if index == 14 {
    _hamt{...hamt, entry14: entry}
  } else if index == 15 {
    _hamt{...hamt, entry15: entry}
  } else if index == 16 {
    _hamt{...hamt, entry16: entry}
  } else if index == 17 {
    _hamt{...hamt, entry17: entry}
  } else if index == 18 {
    _hamt{...hamt, entry18: entry}
  } else if index == 19 {
    _hamt{...hamt, entry19: entry}
  } else if index == 20 {
    _hamt{...hamt, entry20: entry}
  } else if index == 21 {
    _hamt{...hamt, entry21: entry}
  } else if index == 22 {
    _hamt{...hamt, entry22: entry}
  } else if index == 23 {
    _hamt{...hamt, entry23: entry}
  } else if index == 24 {
    _hamt{...hamt, entry24: entry}
  } else if index == 25 {
    _hamt{...hamt, entry25: entry}
  } else if index == 26 {
    _hamt{...hamt, entry26: entry}
  } else if index == 27 {
    _hamt{...hamt, entry27: entry}
  } else if index == 28 {
    _hamt{...hamt, entry28: entry}
  } else if index == 29 {
    _hamt{...hamt, entry29: entry}
  } else if index == 30 {
    _hamt{...hamt, entry30: entry}
  } else if index == 31 {
    _hamt{...hamt, entry31: entry}
  } else {
    _hamt{...hamt, entry32: entry}
  }
}
