import foreign "c" _pen_os_read_stdin \() ffiReadResult
import foreign "c" _pen_os_write_stdout \(string) ffiWriteResult
import foreign "c" _pen_os_write_stderr \(string) ffiWriteResult
import foreign "c" _pen_os_open_file \(string, OpenFileOptions) ffiOpenResult
import foreign "c" _pen_os_read_file \(any) ffiReadResult
import foreign "c" _pen_os_write_file \(any, string) ffiWriteResult
import foreign "c" _pen_os_copy_file \(string, string) ffiNoneResult
import foreign "c" _pen_os_remove_file \(string) ffiNoneResult
import foreign _pen_main \(Os) number

type Os {
  readStdIn \() ffiReadResult,
  writeStdOut \(string) ffiWriteResult,
  writeStdErr \(string) ffiWriteResult,
  openFile \(string, OpenFileOptions) ffiOpenResult,
  readFile \(any) ffiReadResult,
  writeFile \(any, string) ffiWriteResult,
  copyFile \(string, string) ffiNoneResult,
  removeFile \(string) ffiNoneResult,
}

type File {
  inner file | specialFile,
}

type file {
  inner any,
}

type stdIn {}
type stdOut {}
type stdErr {}

type ffiOpenResult {
  file any,
  error number,
}

type ffiReadResult {
  data string,
  error number,
}

type ffiWriteResult {
  count number,
  error number,
}

type ffiNoneResult {
  _ none,
  error number,
}

type OpenFileOptions {
  Append boolean,
  Create boolean,
  CreateNew boolean,
  Read boolean,
  Truncate boolean,
  Write boolean,
}

type specialFile = stdIn | stdOut | stdErr

StdIn = \() File {
  File{inner: stdIn}
}

StdOut = \() File {
  File{inner: stdOut}
}

StdErr = \() File {
  File{inner: stdErr}
}

DefaultOpenFileOptions = \() OpenFileOptions {
  OpenFileOptions{
    Append: false,
    Create: false,
    CreateNew: false,
    Read: false,
    Truncate: false,
    Write: false,
  }
}

OpenFileWithOptions = \(os Os, path string, opts OpenFileOptions) File | error {
  r = os.openFile(path, opts)

  if r.error == 0 {
    File{inner: file{inner: r.file}}
  } else {
    error(translateError(r.error))
  }
}

OpenFile = \(os Os, path string) File | error {
  OpenFileWithOptions(
    os,
    path,
    OpenFileOptions{...DefaultOpenFileOptions(), Read: true}
  )
}

ReadFile = \(os Os, file File) string | error {
  r = if f = file.inner; stdIn {
    os.readStdIn()
  } else if stdOut {
    error("cannot read from stdout")
  } else if stdErr {
    error("cannot read from stderr")
  } else if file {
    os.readFile(f.inner)
  }?

  if r.error == 0 {
    r.data
  } else {
    error(translateError(r.error))
  }
}

WriteFile = \(os Os, file File, data string) number | error {
  r = if f = file.inner; stdIn {
    error("cannot write to stdin")
  } else if stdOut {
    os.writeStdOut(data)
  } else if stdErr {
    os.writeStdErr(data)
  } else if file {
    os.writeFile(f.inner, data)
  }?

  if r.error == 0 {
    r.count
  } else {
    error(translateError(r.error))
  }
}

CopyFile = \(os Os, src string, dest string) none | error {
  r = os.copyFile(src, dest)

  if r.error == 0 {
    none
  } else {
    error(translateError(r.error))
  }
}

RemoveFile = \(os Os, path string) none | error {
  r = os.removeFile(path)

  if r.error == 0 {
    none
  } else {
    error(translateError(r.error))
  }
}

translateError = \(code number) string {
  if code == 1 {
    "operation not permitted"
  } else if code == 2 {
    "no such file or directory"
  } else if code == 13 {
    "permission denied"
  } else if code == 17 {
    "file exists"
  } else if code == 20 {
    "not a directory"
  } else if code == 257 {
    "cannot lock file"
  } else if code == 258 {
    "cannot decode path as utf8"
  } else {
    "unknown io error"
  }
}

export foreign _pen_os_main = \(_ none) number {
  _pen_main(
    Os{
      readStdIn: _pen_os_read_stdin,
      writeStdOut: _pen_os_write_stdout,
      writeStdErr: _pen_os_write_stderr,
      openFile: _pen_os_open_file,
      readFile: _pen_os_read_file,
      writeFile: _pen_os_write_file,
      copyFile: _pen_os_copy_file,
      removeFile: _pen_os_remove_file,
    },
  )
}
